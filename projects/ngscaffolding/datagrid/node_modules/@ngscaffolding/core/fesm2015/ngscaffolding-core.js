import { ɵɵdefineInjectable, ɵsetClassMetadata, Injectable, ɵɵinject, NgModuleFactoryLoader, Injector, ErrorHandler, ɵɵdirectiveInject, ElementRef, ɵɵdefineDirective, ɵɵlistener, ɵɵresolveWindow, Directive, Input, HostListener, ɵɵdefinePipe, Pipe, EventEmitter, ɵɵdefineComponent, ɵɵNgOnChangesFeature, ɵɵelementStart, ɵɵtext, ɵɵelementEnd, Component, Output, ɵɵdefineNgModule, ɵɵdefineInjector, ɵɵsetNgModuleScope, NgModule } from '@angular/core';
import { EntityStore, StoreConfig, QueryEntity, Store, Query, toBoolean, QueryConfig, Order, resetStores } from '@datorama/akita';
import { __decorate, __awaiter } from 'tslib';
import { createBasicUser, AppSettings, ZuluDateHelper, ErrorModel, BasicUser, UserPreferenceValue } from '@ngscaffolding/models';
import { filter, map, timeout, retry, finalize, take } from 'rxjs/operators';
import { Subject, of, Observable, combineLatest, BehaviorSubject } from 'rxjs';
import { HttpClient, HttpParams, HttpHeaders, HttpClientModule } from '@angular/common/http';
import { v4 } from 'uuid';
import { JwtHelperService } from '@auth0/angular-jwt';
import { Router } from '@angular/router';
import { UserManager } from 'oidc-client';
import * as dateFormatimp from 'dateformat';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

let AppSettingsStore = class AppSettingsStore extends EntityStore {
    constructor() {
        super({ isInitialised: false });
        console.log('AppSettingsStore Constructor');
    }
};
AppSettingsStore.ɵfac = function AppSettingsStore_Factory(t) { return new (t || AppSettingsStore)(); };
AppSettingsStore.ɵprov = ɵɵdefineInjectable({ token: AppSettingsStore, factory: AppSettingsStore.ɵfac, providedIn: 'root' });
AppSettingsStore = __decorate([
    StoreConfig({ name: 'appSettings', idKey: 'name' })
], AppSettingsStore);
/*@__PURE__*/ (function () { ɵsetClassMetadata(AppSettingsStore, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();

class AppSettingsQuery extends QueryEntity {
    constructor(store) {
        super(store);
        this.store = store;
        this.isInitialised$ = this.select(state => state.isInitialised);
    }
}
AppSettingsQuery.ɵfac = function AppSettingsQuery_Factory(t) { return new (t || AppSettingsQuery)(ɵɵinject(AppSettingsStore)); };
AppSettingsQuery.ɵprov = ɵɵdefineInjectable({ token: AppSettingsQuery, factory: AppSettingsQuery.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(AppSettingsQuery, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: AppSettingsStore }]; }, null); })();

class BroadcastService {
    constructor() {
        this._eventBus = new Subject();
    }
    broadcast(key, data) {
        this._eventBus.next({ key, data });
    }
    on(key) {
        return this._eventBus.pipe(filter(event => event.key === key), map(event => event.data));
    }
}
BroadcastService.ɵfac = function BroadcastService_Factory(t) { return new (t || BroadcastService)(); };
BroadcastService.ɵprov = ɵɵdefineInjectable({ token: BroadcastService, factory: BroadcastService.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(BroadcastService, [{
        type: Injectable,
        args: [{
                providedIn: 'root',
            }]
    }], function () { return []; }, null); })();

class NotificationService {
    constructor(broadcast) {
        this.broadcast = broadcast;
    }
    showMessage(message) {
        this.broadcast.broadcast("SHOW_MESSAGE" /* SHOW_MESSAGE */, message);
    }
}
NotificationService.ɵfac = function NotificationService_Factory(t) { return new (t || NotificationService)(ɵɵinject(BroadcastService)); };
NotificationService.ɵprov = ɵɵdefineInjectable({ token: NotificationService, factory: NotificationService.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(NotificationService, [{
        type: Injectable,
        args: [{
                providedIn: 'root',
            }]
    }], function () { return [{ type: BroadcastService }]; }, null); })();

let AuthenticationStore = class AuthenticationStore extends Store {
    constructor() {
        super({ userDetails: createBasicUser() });
        console.log('AuthenticationStore Constructor');
    }
};
AuthenticationStore.ɵfac = function AuthenticationStore_Factory(t) { return new (t || AuthenticationStore)(); };
AuthenticationStore.ɵprov = ɵɵdefineInjectable({ token: AuthenticationStore, factory: AuthenticationStore.ɵfac, providedIn: 'root' });
AuthenticationStore = __decorate([
    StoreConfig({ name: 'authorisation' })
], AuthenticationStore);
/*@__PURE__*/ (function () { ɵsetClassMetadata(AuthenticationStore, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();

class UserAuthenticationQuery extends Query {
    constructor(store) {
        super(store);
        this.store = store;
        this.authenticated$ = this.select(state => state.authenticated);
        this.currentUser$ = this.select(state => state.userDetails);
    }
    isAuthenticated() {
        return toBoolean(this.getValue().authenticated);
    }
    getUserId() {
        if (this.isAuthenticated() && this.getValue().userDetails) {
            return this.getValue().userDetails.userId;
        }
        else {
            return null;
        }
    }
    getUser() {
        return this.getValue().userDetails;
    }
}
UserAuthenticationQuery.ɵfac = function UserAuthenticationQuery_Factory(t) { return new (t || UserAuthenticationQuery)(ɵɵinject(AuthenticationStore)); };
UserAuthenticationQuery.ɵprov = ɵɵdefineInjectable({ token: UserAuthenticationQuery, factory: UserAuthenticationQuery.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(UserAuthenticationQuery, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: AuthenticationStore }]; }, null); })();

class LoggingService {
    constructor(notification, appSettingsQuery, userQuery, http) {
        this.notification = notification;
        this.appSettingsQuery = appSettingsQuery;
        this.userQuery = userQuery;
        this.http = http;
    }
    error(err, methodName = '', showToast = false) {
        if (!methodName) {
            console.error(`Method ${methodName}: Error ${err}`);
        }
        else {
            console.error(`Error ${err}`);
        }
        // TODO: Resume showing toast
        if (showToast) {
            this.notification.showMessage({
                severity: 'error',
                summary: 'Error',
                detail: err.message
            });
        }
    }
    warning(message, methodName = '') {
        if (!methodName) {
            console.warn(`Method ${methodName}: Warning ${message}`);
        }
        else {
            console.warn(`Warning ${message}`);
        }
    }
    info(message, methodName = '', objectInfo = null) {
        if (!methodName) {
            // tslint:disable-next-line:no-console
            console.info(`Info : ${message}`, objectInfo);
        }
        else {
            // tslint:disable-next-line:no-console
            console.info(`[${methodName}] : ${message}`, objectInfo);
        }
    }
}
LoggingService.ɵfac = function LoggingService_Factory(t) { return new (t || LoggingService)(ɵɵinject(NotificationService), ɵɵinject(AppSettingsQuery), ɵɵinject(UserAuthenticationQuery), ɵɵinject(HttpClient)); };
LoggingService.ɵprov = ɵɵdefineInjectable({ token: LoggingService, factory: LoggingService.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(LoggingService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: NotificationService }, { type: AppSettingsQuery }, { type: UserAuthenticationQuery }, { type: HttpClient }]; }, null); })();

class AppSettingsService {
    constructor(appSettingsStore, appSettingsQuery, logger, http) {
        this.appSettingsStore = appSettingsStore;
        this.appSettingsQuery = appSettingsQuery;
        this.logger = logger;
        this.http = http;
        this.className = 'AppSettingsService';
        console.log('AppSettingsService Constructor');
    }
    setValue(name, value) {
        if (this.appSettingsQuery.hasEntity(name)) {
            this.appSettingsStore.update(name, { name: name, value: value });
        }
        else {
            this.appSettingsStore.add({ name: name, value: value });
        }
        if (name === AppSettings.apiHome) {
            this.loadFromServer(value.toString());
        }
    }
    getValue(name) {
        if (this.appSettingsQuery.hasEntity(name)) {
            return this.appSettingsQuery.getEntity(name).value;
        }
        else {
            return null;
        }
    }
    loadFromServer(apiHome) {
        // Mark store as loading
        this.appSettingsStore.setLoading(true);
        // Load values from Server
        this.http
            .get(`${apiHome}/api/v1/appSettings`)
            .pipe(timeout(20000), retry(3))
            .subscribe(appValues => {
            if (appValues) {
                appValues.forEach(appValue => {
                    this.setValue(appValue.name, appValue.value);
                });
            }
            this.appSettingsStore.setLoading(false);
            this.appSettingsStore.update({ isInitialised: true });
        }, err => {
            this.appSettingsStore.setLoading(false);
        });
    }
    setValues(settings) {
        // Mark store as loading
        this.appSettingsStore.setLoading(true);
        this.appSettingsStore.update({ isInitialised: false });
        // Load values
        if (settings) {
            Object.keys(settings).forEach(key => {
                // Setting Value Here
                this.logger.info(`[${this.className}.loadSettings] Setting Value ${key} = ${settings[key]}`);
                this.setValue(key, settings[key]);
            });
        }
        this.appSettingsStore.setLoading(false);
        this.appSettingsStore.update({ isInitialised: true });
    }
    getBoolean(name) {
        return this.appSettingsQuery.selectEntity(name, entity => entity.value);
    }
    getString(name) {
        return this.appSettingsQuery.selectEntity(name, entity => entity.value);
    }
}
AppSettingsService.ɵfac = function AppSettingsService_Factory(t) { return new (t || AppSettingsService)(ɵɵinject(AppSettingsStore), ɵɵinject(AppSettingsQuery), ɵɵinject(LoggingService), ɵɵinject(HttpClient)); };
AppSettingsService.ɵprov = ɵɵdefineInjectable({ token: AppSettingsService, factory: AppSettingsService.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(AppSettingsService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: AppSettingsStore }, { type: AppSettingsQuery }, { type: LoggingService }, { type: HttpClient }]; }, null); })();

class AppAuditService {
    constructor(appSettingsQuery, userQuery, http) {
        this.appSettingsQuery = appSettingsQuery;
        this.userQuery = userQuery;
        this.http = http;
    }
    RecordLog(appLog) {
        let apiHome = this.appSettingsQuery.getEntity(AppSettings.apiHome).value;
        if (!appLog.logDate) {
            appLog.logDate = ZuluDateHelper.setGMTDate(new Date());
        }
        if (!appLog.userID) {
            appLog.userID = this.userQuery.getUserId();
        }
        try {
            // This post is a fire and forget. Don't have to authorise either
            this.http
                .post(`${apiHome}/api/v1/applicationLog`, appLog)
                .pipe(timeout(30000), retry(3))
                .subscribe((data) => { }, (err) => {
                console.log('Unable to send AppLog, offline?');
            });
        }
        catch (err) {
            console.log('Unable to send AppLog, offline?');
        }
    }
}
AppAuditService.ɵfac = function AppAuditService_Factory(t) { return new (t || AppAuditService)(ɵɵinject(AppSettingsQuery), ɵɵinject(UserAuthenticationQuery), ɵɵinject(HttpClient)); };
AppAuditService.ɵprov = ɵɵdefineInjectable({ token: AppAuditService, factory: AppAuditService.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(AppAuditService, [{
        type: Injectable,
        args: [{
                providedIn: 'root',
            }]
    }], function () { return [{ type: AppSettingsQuery }, { type: UserAuthenticationQuery }, { type: HttpClient }]; }, null); })();

let AuditLogStore = class AuditLogStore extends EntityStore {
    constructor() {
        super({});
        console.log('AuditLogStore Constructor');
    }
};
AuditLogStore.ɵfac = function AuditLogStore_Factory(t) { return new (t || AuditLogStore)(); };
AuditLogStore.ɵprov = ɵɵdefineInjectable({ token: AuditLogStore, factory: AuditLogStore.ɵfac, providedIn: 'root' });
AuditLogStore = __decorate([
    StoreConfig({ name: 'auditLog', idKey: 'id' })
], AuditLogStore);
/*@__PURE__*/ (function () { ɵsetClassMetadata(AuditLogStore, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();

class AuditLogQuery extends QueryEntity {
    constructor(store) {
        super(store);
        this.store = store;
        this.allAuditLog = this.getAll();
    }
}
AuditLogQuery.ɵfac = function AuditLogQuery_Factory(t) { return new (t || AuditLogQuery)(ɵɵinject(AuditLogStore)); };
AuditLogQuery.ɵprov = ɵɵdefineInjectable({ token: AuditLogQuery, factory: AuditLogQuery.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(AuditLogQuery, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: AuditLogStore }]; }, null); })();

class AuditLogService {
    constructor(auditLogStore, auditLogQuery, appSettingsQuery, userQuery, http) {
        this.auditLogStore = auditLogStore;
        this.auditLogQuery = auditLogQuery;
        this.appSettingsQuery = appSettingsQuery;
        this.userQuery = userQuery;
        this.http = http;
        this.polling = 30000;
        this.retryVal = 3;
        this.isSending = false;
        this.defaultLog = {};
        appSettingsQuery
            .selectEntity(AppSettings.mobileDefaultPolling)
            .subscribe(val => (this.polling = val.value > 0 ? val.value : 30000));
        appSettingsQuery
            .selectEntity(AppSettings.mobileDefaultRetries)
            .subscribe(val => (this.retryVal = val.value > 0 ? val.value : 3));
        this.StartPolling();
    }
    SetDefault(defaultLog) {
        this.defaultLog = defaultLog;
    }
    RecordLog(auditLog) {
        const workingLog = Object.assign(Object.assign({}, this.defaultLog), auditLog);
        workingLog.id = v4();
        if (!workingLog.logDate) {
            workingLog.logDate = ZuluDateHelper.setGMTDate(new Date());
        }
        if (!workingLog.userID) {
            workingLog.userID = this.userQuery.getUserId();
        }
        this.auditLogStore.add(workingLog);
        try {
        }
        catch (err) {
            console.log('Unable to send AppLog, offline?');
        }
    }
    StartPolling() {
        setInterval(_ => {
            if (!this.isSending) {
                this.isSending = true;
                this.SendLogEntries();
            }
        }, this.polling);
    }
    SendLogEntries() {
        const apiHome = this.appSettingsQuery.getEntity(AppSettings.apiHome).value;
        const logEntries = this.auditLogQuery.getAll();
        if (logEntries && logEntries.length > 0) {
            const keys = logEntries.map(log => log.id);
            // This post is a fire and forget. Don't have to authorise either
            this.http
                .post(`${apiHome}/api/v1/auditlog`, logEntries)
                .pipe(timeout(30000), retry(3), finalize(() => {
                this.isSending = false;
            }))
                .subscribe(data => {
                this.auditLogStore.remove(keys);
                // keys.forEach(key => this.auditLogStore.remove(({ id }) => id === key));
            }, err => {
                console.log('Unable to send AppLog, offline?');
            });
        }
        else {
            this.isSending = false;
        }
    }
}
AuditLogService.ɵfac = function AuditLogService_Factory(t) { return new (t || AuditLogService)(ɵɵinject(AuditLogStore), ɵɵinject(AuditLogQuery), ɵɵinject(AppSettingsQuery), ɵɵinject(UserAuthenticationQuery), ɵɵinject(HttpClient)); };
AuditLogService.ɵprov = ɵɵdefineInjectable({ token: AuditLogService, factory: AuditLogService.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(AuditLogService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: AuditLogStore }, { type: AuditLogQuery }, { type: AppSettingsQuery }, { type: UserAuthenticationQuery }, { type: HttpClient }]; }, null); })();

class ComponentLoaderService {
    constructor(loader, injector) {
        this.loader = loader;
        this.injector = injector;
        this.componentRegistry = {
            'lazy-component': {
                modulePath: './lazy-components/lazy-components.module#LazyComponentsModule',
                moduleRef: null
            }
        };
    }
    registerComponent(name, modulePath = null) {
        if (!this.componentRegistry[name]) {
            this.componentRegistry[name] = {
                modulePath: modulePath,
                moduleRef: null
            };
        }
    }
    loadComponent(componentTag) {
        const cmpRegistryEntry = this.componentRegistry[componentTag];
        if (!cmpRegistryEntry) {
            throw new Error(`Unrecognized component "${componentTag}". Make sure it is registered in the component registry`);
        }
        if (cmpRegistryEntry.modulePath) {
            // Provided a path so this is a lazy loaded component
            if (cmpRegistryEntry.moduleRef) {
                return new Promise(resolve => {
                    const componentInstance = document.createElement(componentTag);
                    resolve(componentInstance);
                });
            }
            else {
                const path = cmpRegistryEntry.modulePath;
                return new Promise((resolve, reject) => {
                    this.loader
                        .load(path)
                        .then(moduleFactory => {
                        const moduleRef = moduleFactory.create(this.injector).instance;
                        cmpRegistryEntry.moduleRef = moduleRef;
                        // instantiate the component
                        const componentInstance = document.createElement(componentTag);
                        resolve(componentInstance);
                    })
                        .catch(err => {
                        console.error('error loading module', err);
                        reject(err);
                    });
                });
            }
        }
        else {
            // No path so simple Angular Element already webpacked
            return new Promise((resolve, reject) => {
                const componentInstance = document.createElement(componentTag);
                resolve(componentInstance);
            });
        }
    }
}
ComponentLoaderService.ɵfac = function ComponentLoaderService_Factory(t) { return new (t || ComponentLoaderService)(ɵɵinject(NgModuleFactoryLoader), ɵɵinject(Injector)); };
ComponentLoaderService.ɵprov = ɵɵdefineInjectable({ token: ComponentLoaderService, factory: ComponentLoaderService.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(ComponentLoaderService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: NgModuleFactoryLoader }, { type: Injector }]; }, null); })();

class CoreErrorHandlerService extends ErrorHandler {
    constructor(appSettingsService, http) {
        super();
        this.appSettingsService = appSettingsService;
        this.http = http;
    }
    logError(error, source = null) { }
    processError(error, source = null) { }
    handleError(error, source = null) {
        super.handleError(error);
        if (this.appSettingsService.getValue(AppSettings.errorLogConsole)) {
            console.error(error.message);
        }
        if (this.appSettingsService.getValue(AppSettings.errorLogServer)) {
            const errorModel = new ErrorModel(error);
            if (source) {
                errorModel.source = source;
            }
            if (error.stack) {
                errorModel.stackTrace = error.stack;
            }
            // Consume any errors here. Otherwise we will just get stuck
            try {
                // This post is a fire and forget. Don't have to authorise either
                this.http.post(this.appSettingsService.getValue(AppSettings.apiHome) + '/api/v1/error', errorModel).subscribe(data => {
                    // alert('ID: ' + data.id);
                }, err => {
                    console.log('Unable to send Error to Server, offline?');
                });
            }
            catch (err) {
                console.log('Unable to send Error to Server, offline?');
            }
        }
        if (this.appSettingsService.getValue(AppSettings.errorShowUser)) {
            // TODO: Show User Error
        }
    }
}
CoreErrorHandlerService.ɵfac = function CoreErrorHandlerService_Factory(t) { return new (t || CoreErrorHandlerService)(ɵɵinject(AppSettingsService), ɵɵinject(HttpClient)); };
CoreErrorHandlerService.ɵprov = ɵɵdefineInjectable({ token: CoreErrorHandlerService, factory: CoreErrorHandlerService.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(CoreErrorHandlerService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: AppSettingsService }, { type: HttpClient }]; }, null); })();

let DataSourceStore = class DataSourceStore extends EntityStore {
    constructor() {
        super({ isInitialised: false });
        console.log('DataSourceStore Constructor');
    }
};
DataSourceStore.ɵfac = function DataSourceStore_Factory(t) { return new (t || DataSourceStore)(); };
DataSourceStore.ɵprov = ɵɵdefineInjectable({ token: DataSourceStore, factory: DataSourceStore.ɵfac, providedIn: 'root' });
DataSourceStore = __decorate([
    StoreConfig({ name: 'dataSource', idKey: 'key' })
], DataSourceStore);
/*@__PURE__*/ (function () { ɵsetClassMetadata(DataSourceStore, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();

class DataSourceQuery extends QueryEntity {
    constructor(store) {
        super(store);
        this.store = store;
        this.isInitialised$ = this.select(state => state.isInitialised);
    }
}
DataSourceQuery.ɵfac = function DataSourceQuery_Factory(t) { return new (t || DataSourceQuery)(ɵɵinject(DataSourceStore)); };
DataSourceQuery.ɵprov = ɵɵdefineInjectable({ token: DataSourceQuery, factory: DataSourceQuery.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(DataSourceQuery, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: DataSourceStore }]; }, null); })();

class DataSourceService {
    constructor(http, dataSourceStore, dataSourceQuery, appSettingsService, appAuditService, logger) {
        this.http = http;
        this.dataSourceStore = dataSourceStore;
        this.dataSourceQuery = dataSourceQuery;
        this.appSettingsService = appSettingsService;
        this.appAuditService = appAuditService;
        this.logger = logger;
        this.className = 'DataSourceService';
        this.inflightRequests = new Map();
    }
    decorateInput(inputDetails) {
        return null;
    }
    getDataSource(dataRequest) {
        const key = this.getKey(dataRequest);
        if (dataRequest.forceRefresh) {
            this.dataSourceStore.remove(key);
        }
        const currentCacheValue = this.dataSourceQuery.getEntity(key);
        if (currentCacheValue) {
            if (currentCacheValue.expiresWhen > new Date()) {
                // Return good cached value
                return of(currentCacheValue);
            }
            else {
                // Expired - Bad cache
                this.dataSourceStore.remove(key);
            }
        }
        if (this.inflightRequests.has(key)) {
            return this.inflightRequests.get(key);
        }
        // Make HTTP Request
        const formData = new FormData();
        formData.append('dataSourceRequest', JSON.stringify(dataRequest));
        // Add Files if passed
        if (dataRequest.fileNames) {
            let fileCount = 0;
            dataRequest.fileNames.forEach((file) => {
                formData.append(`file-${fileCount++}`, file, file.name);
            });
        }
        const logEntry = {
            entity: 'DataSource Call',
            action: key,
            values: {
                filterValues: dataRequest.filterValues,
                inputData: dataRequest.inputData,
            },
        };
        this.logger.info(`Calling Datasource ${dataRequest.name}`, null, logEntry.values);
        this.inflightRequests.set(key, new Observable((observer) => {
            this.http
                .post(`${this.appSettingsService.getValue(AppSettings.apiHome)}/api/v1/datasource`, formData)
                .pipe(timeout(20000), retry(3))
                .subscribe((values) => {
                const expiryNow = new Date();
                // If expires Seconds not provided set long expiry
                const expiresSeconds = values.expiresSeconds > 0 ? values.expiresSeconds : 99999999;
                const expiresWhen = new Date(expiryNow.getTime() + expiresSeconds * 10000);
                const newResults = {
                    expiresWhen: expiresWhen,
                    rowCount: values.rowCount,
                    jsonData: values.jsonData,
                    results: values.results,
                };
                // Log Datasource Success
                this.appAuditService.RecordLog(Object.assign(Object.assign({}, logEntry), { result: 'Success' }));
                // Update the Store to tell the world we have data
                this.dataSourceStore.update(key, newResults);
                this.inflightRequests.delete(key);
                observer.next(newResults);
                observer.complete();
            }, (err) => {
                // Update the Store to tell the world we failed in every way. Shame.
                const errorResults = {
                    expiresWhen: new Date(),
                    error: err.message,
                };
                // Log Datasource Success
                this.appAuditService.RecordLog(Object.assign(Object.assign({}, logEntry), { result: err.message }));
                this.dataSourceStore.update(key, errorResults);
                this.inflightRequests.delete(key);
                this.logger.error(err, 'DataSource.Service.getDataSource', false);
                observer.error(err);
            });
        }));
        return this.inflightRequests.get(key);
    }
    getKey(dataRequest) {
        return `name:${dataRequest.name} seed:${dataRequest.seed} inputData:${JSON.stringify(dataRequest.inputData)} `;
    }
}
DataSourceService.ɵfac = function DataSourceService_Factory(t) { return new (t || DataSourceService)(ɵɵinject(HttpClient), ɵɵinject(DataSourceStore), ɵɵinject(DataSourceQuery), ɵɵinject(AppSettingsService), ɵɵinject(AppAuditService), ɵɵinject(LoggingService)); };
DataSourceService.ɵprov = ɵɵdefineInjectable({ token: DataSourceService, factory: DataSourceService.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(DataSourceService, [{
        type: Injectable,
        args: [{
                providedIn: 'root',
            }]
    }], function () { return [{ type: HttpClient }, { type: DataSourceStore }, { type: DataSourceQuery }, { type: AppSettingsService }, { type: AppAuditService }, { type: LoggingService }]; }, null); })();

let MenuStore = class MenuStore extends EntityStore {
    constructor() {
        super();
        console.log('MenuStore Constructor');
    }
};
MenuStore.ɵfac = function MenuStore_Factory(t) { return new (t || MenuStore)(); };
MenuStore.ɵprov = ɵɵdefineInjectable({ token: MenuStore, factory: MenuStore.ɵfac, providedIn: 'root' });
MenuStore = __decorate([
    StoreConfig({ name: 'menu', idKey: 'name' })
], MenuStore);
/*@__PURE__*/ (function () { ɵsetClassMetadata(MenuStore, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();

let MenuQuery = class MenuQuery extends QueryEntity {
    constructor(store) {
        super(store);
        this.store = store;
        this.folders$ = this.selectAll({
            filterBy: [entity => entity.type === "folder" /* Folder */]
        });
    }
};
MenuQuery.ɵfac = function MenuQuery_Factory(t) { return new (t || MenuQuery)(ɵɵinject(MenuStore)); };
MenuQuery.ɵprov = ɵɵdefineInjectable({ token: MenuQuery, factory: MenuQuery.ɵfac, providedIn: 'root' });
MenuQuery = __decorate([
    QueryConfig({
        sortBy: 'order',
        sortByOrder: Order.ASC // Order.DESC
    })
], MenuQuery);
/*@__PURE__*/ (function () { ɵsetClassMetadata(MenuQuery, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: MenuStore }]; }, null); })();

let RolesStore = class RolesStore extends EntityStore {
    constructor() {
        super();
        console.log('RoleStore Constructor');
    }
};
RolesStore.ɵfac = function RolesStore_Factory(t) { return new (t || RolesStore)(); };
RolesStore.ɵprov = ɵɵdefineInjectable({ token: RolesStore, factory: RolesStore.ɵfac, providedIn: 'root' });
RolesStore = __decorate([
    StoreConfig({ name: 'role', idKey: 'name' })
], RolesStore);
/*@__PURE__*/ (function () { ɵsetClassMetadata(RolesStore, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();

class RolesQuery extends QueryEntity {
    constructor(store) {
        super(store);
        this.store = store;
    }
}
RolesQuery.ɵfac = function RolesQuery_Factory(t) { return new (t || RolesQuery)(ɵɵinject(RolesStore)); };
RolesQuery.ɵprov = ɵɵdefineInjectable({ token: RolesQuery, factory: RolesQuery.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(RolesQuery, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: RolesStore }]; }, null); })();

class RolesService {
    constructor(http, rolesQuery, appSettingsQuery, dataSourceService, rolesStore, authQuery) {
        this.http = http;
        this.rolesQuery = rolesQuery;
        this.appSettingsQuery = appSettingsQuery;
        this.dataSourceService = dataSourceService;
        this.rolesStore = rolesStore;
        this.authQuery = authQuery;
        this.routeRoles = new Map();
        // First Time load away
        this.rolesStore.setLoading(false);
        // Wait for settings, then load from server
        combineLatest(this.authQuery.authenticated$, this.appSettingsQuery.selectEntity(AppSettings.apiHome)).subscribe(([authenticated, apiHome]) => {
            if (authenticated && apiHome) {
                this.apiHome = apiHome.value;
                this.rolesQuery
                    .selectLoading()
                    .pipe(take(1))
                    .subscribe(loading => {
                    if (!loading) {
                        this.downloadRoles();
                    }
                });
            }
            else if (!authenticated) {
                this.rolesStore.remove();
            }
        });
    }
    downloadRoles() {
        // Mark loading status
        this.rolesStore.setLoading(true);
        this.dataSourceService
            .getDataSource({ name: "system.Roles.Select" /* ROLES_SELECT */ })
            .pipe(finalize(() => {
            this.rolesStore.setLoading(false);
        }))
            .subscribe(results => {
            if (results && !results.error) {
                this.rolesStore.add(results.jsonData);
                this.rolesStore.setLoading(false);
            }
        });
    }
    // Checks if the current user is in this role.
    isInRole(role) {
        const currentUser = this.authQuery.getValue().userDetails;
        if (currentUser && currentUser.role) {
            return currentUser.role.indexOf(role) > -1;
        }
        else {
            return false;
        }
    }
    // Checks if the current user is in one of these roles.
    isInRoles(roles) {
        let result = false;
        const currentUser = this.authQuery.getValue().userDetails;
        if (currentUser && currentUser.role) {
            roles.forEach(role => {
                if (currentUser.role.indexOf(role) > -1) {
                    result = true;
                }
            });
        }
        return result;
    }
    // Repository of Roles: Routes
    addRouteRoles(route, roles) {
        this.routeRoles.set(route, roles);
    }
    getRouteRoles(route) {
        return this.routeRoles.get(route);
    }
}
RolesService.ɵfac = function RolesService_Factory(t) { return new (t || RolesService)(ɵɵinject(HttpClient), ɵɵinject(RolesQuery), ɵɵinject(AppSettingsQuery), ɵɵinject(DataSourceService), ɵɵinject(RolesStore), ɵɵinject(UserAuthenticationQuery)); };
RolesService.ɵprov = ɵɵdefineInjectable({ token: RolesService, factory: RolesService.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(RolesService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: HttpClient }, { type: RolesQuery }, { type: AppSettingsQuery }, { type: DataSourceService }, { type: RolesStore }, { type: UserAuthenticationQuery }]; }, null); })();

class MenuService {
    constructor(http, menuStore, menuQuery, appSettingsQuery, authQuery, log, rolesService) {
        this.http = http;
        this.menuStore = menuStore;
        this.menuQuery = menuQuery;
        this.appSettingsQuery = appSettingsQuery;
        this.authQuery = authQuery;
        this.log = log;
        this.rolesService = rolesService;
        this.methodName = 'MenuService';
        this.masterListMenu = [];
        this.routes = [];
        this.menuItems = [];
        this.routeSubject = new BehaviorSubject(this.routes);
        this.httpInFlight = false;
        this.lockCount = 0;
        this.menuDownloaded = false;
        // Wait for settings, then load from server
        combineLatest([
            this.authQuery.authenticated$,
            this.appSettingsQuery.selectEntity(AppSettings.apiHome),
            this.appSettingsQuery.selectEntity(AppSettings.isMobile)
        ]).subscribe(([authenticated, apiHome, isMobile]) => {
            if (authenticated && apiHome && isMobile && !this.menuDownloaded) {
                this.apiHome = apiHome.value;
                if (!this.httpInFlight) {
                    this.downloadMenuItems(isMobile.value || false);
                }
            }
            else if (!authenticated) {
                this.menuDownloaded = false;
                this.lockCount = 0;
            }
        });
    }
    addLock() {
        this.lockCount++;
        this.log.info(`MENU Service: Locks on Loading`, this.methodName, this.lockCount);
        this.menuStore.setLoading(true);
    }
    setCurrent(name) {
        this.menuStore.setActive(name);
    }
    removeLock() {
        this.lockCount--;
        this.log.info(`MENU Service: Locks on Loading`, this.methodName, this.lockCount);
        if (this.lockCount === 0) {
            this.menuStore.setLoading(false);
        }
    }
    addMenuItemsFromCode(menuItems, roles = null) {
        this.addLock();
        this.log.info('Adding MenuItems menuItems', this.methodName, menuItems);
        // Wait till user authorised
        this.authQuery.authenticated$.subscribe(authorised => {
            if (authorised) {
                // Save for later use
                this.addMenuItems(menuItems);
                this.removeLock();
            }
        });
    }
    getFolders() {
        return this.menuQuery.getAll({
            filterBy: [entity => entity.type === "folder" /* Folder */]
        });
    }
    delete(menuItem) {
        return new Observable(observer => {
            const obs = this.http.delete(`${this.apiHome}/api/v1/menuitems/${menuItem.name}`);
            obs.subscribe(() => {
                // Remove from our store
                this.menuStore.remove(menuItem.name);
                // Remove from Tree
                const existingMenus = JSON.parse(JSON.stringify(this.menuQuery.getValue())).menuItems;
                let parentMenu;
                if (menuItem.parent) {
                    parentMenu = existingMenus.find(menu => menu.name && menu.name.toLowerCase() === menuItem.parent.toLowerCase());
                }
                const foundIndex = parentMenu.items.findIndex(childMenu => childMenu.name && childMenu.name === menuItem.name);
                parentMenu.items.splice(foundIndex, 1);
                // Update tree and tell the world
                this.menuStore.update({ menuItems: existingMenus });
                observer.next();
                observer.complete();
            }, err => {
                observer.error(err);
            });
        });
    }
    saveMenuItem(menuItem) {
        return this.http.post(this.apiHome + '/api/v1/menuitems', menuItem);
    }
    updateExistingMenuItem(menuItem) {
        // Is this existing?
        const existing = this.menuQuery.hasEntity(menuItem.name);
        if (existing) {
            this.menuStore.upsert(menuItem.name, menuItem);
        }
        else {
            // Add to reference list of menus
            this.menuStore.add(menuItem);
        }
        const existingMenus = JSON.parse(JSON.stringify(this.menuQuery.getAll()));
        let parentMenu;
        if (menuItem.parent) {
            parentMenu = existingMenus.find(menu => menu.name.toLowerCase() === menuItem.parent.toLowerCase());
        }
        // Add to treeview for menu rendering
        if (!parentMenu.items || !Array.isArray(parentMenu.items)) {
            parentMenu.items = [];
        }
        if (existing) {
            const foundIndex = parentMenu.items.findIndex(childMenu => childMenu.name === menuItem.name);
            parentMenu.items[foundIndex] = menuItem;
        }
        else {
            parentMenu.items.push(menuItem);
        }
        // Update tree and tell the world
        this.menuStore.update({ menuItems: existingMenus });
    }
    // Iterative Call
    addMenuItemsToReferenceList(menuItems) {
        menuItems.forEach(menuItem => {
            // Add to Entity Store
            this.menuStore.upsert(menuItem.name, menuItem);
            if (menuItem.items && Array.isArray(menuItem.items)) {
                this.addMenuItemsToReferenceList(menuItem.items);
            }
        });
    }
    removeUnauthorisedMenuItems(menuItems) {
        const user = this.authQuery.getValue();
        let userRoles = [];
        if (user && user.userDetails) {
            userRoles = user.userDetails.role;
        }
        const removingMenus = [];
        let returnMenus = JSON.parse(JSON.stringify(menuItems));
        for (let menuIndex = 0; menuIndex < returnMenus.length; menuIndex++) {
            const menuItem = returnMenus[menuIndex];
            let removingThis = false;
            // makes sure roles is array
            let checkingRoles = [];
            if (!menuItem.roles) {
                checkingRoles = [];
            }
            else if (Array.isArray(menuItem.roles)) {
                checkingRoles = [...menuItem.roles];
            }
            else {
                checkingRoles = [menuItem.roles];
            }
            // Is this role protected
            if (checkingRoles && checkingRoles.length > 0) {
                if (userRoles && checkingRoles.filter(allowedRole => userRoles.indexOf(allowedRole) !== -1).length === 0) {
                    // No Authority. Remove
                    removingThis = true;
                    removingMenus.push(menuItem.name);
                }
            }
            if (!removingThis && menuItem.items) {
                menuItem.items = this.removeUnauthorisedMenuItems(menuItem.items);
            }
        }
        if (removingMenus.length > 0) {
            returnMenus = menuItems.filter(menu => removingMenus.findIndex(remove => remove === menu.name) === -1);
        }
        return returnMenus;
    }
    downloadMenuItems(isMobile) {
        // Mark loading status
        this.addLock();
        this.httpInFlight = true;
        const newMenuItems = [];
        this.http
            .get(`${this.apiHome}/api/v1/menuitems?mobile=${isMobile}`)
            .pipe(timeout(60000), finalize(() => {
            this.httpInFlight = false;
            this.removeLock();
        }))
            .subscribe(downloadedMenuItems => {
            this.log.info(`Downloaded MenuItems`);
            this.menuDownloaded = true;
            this.addMenuItems(downloadedMenuItems);
        }, err => {
            this.log.error('Failed to download Menu');
        });
    }
    addMenuItems(newMenuItems, findInTree = false) {
        // Clone so we can amend
        const fetchedMenuItems = this.menuQuery.getValue().menuItems || [];
        this.menuItems = JSON.parse(JSON.stringify(fetchedMenuItems));
        this.calculateRouterLinks(newMenuItems);
        // Add to flat reference List
        this.addMenuItemsToReferenceList(newMenuItems);
        if (findInTree) {
            newMenuItems.forEach(loopMenuItem => {
                this.upsertMenuItemToExistingTree(loopMenuItem);
            });
        }
        else {
            newMenuItems.forEach(loopMenuItem => {
                this.addNewMenuItemToEntities(this.menuItems, loopMenuItem);
            });
        }
        // Remove the unatuhorised
        this.menuItems = this.removeUnauthorisedMenuItems(this.menuItems);
        this.menuStore.update({ menuItems: this.menuItems });
    }
    calculateRouterLinks(menuItems) {
        if (menuItems) {
            menuItems.forEach(menuItem => {
                if (!menuItem.routerLink) {
                    // Need to create our routerLink
                    switch (menuItem.type) {
                        case "dashboard" /* Dashboard */: {
                            menuItem.routerLink = `dashboard/${menuItem.name}`;
                            break;
                        }
                        case "datagrid" /* Datagrid */: {
                            menuItem.routerLink = `datagrid/${menuItem.name}`;
                            break;
                        }
                        case "folder" /* Folder */: {
                            // No router link here
                            break;
                        }
                        default: {
                            menuItem.routerLink = menuItem.name;
                        }
                    }
                }
                if (menuItem.items) {
                    this.calculateRouterLinks(menuItem.items);
                }
            });
        }
    }
    addRoute(route, roles = null) {
        this.log.info(`Adding Route ${JSON.stringify(route)}`);
        this.routes.push(route);
        if (roles !== null) {
            this.rolesService.addRouteRoles(route.path, roles);
        }
    }
    upsertMenuItemToExistingTree(newMenuItem) {
        const menuItems = [...this.menuItems];
        if (!newMenuItem.parent || newMenuItem.parent === '') {
            // Root menu item
            let existing = menuItems.find(menu => menu.name === newMenuItem.name);
            if (existing) {
                existing = Object.assign({}, newMenuItem);
            }
            else {
                menuItems.push(Object.assign({}, newMenuItem));
            }
        }
        else {
            // Submenu item
            const parent = menuItems.find(menu => menu.name === newMenuItem.parent);
            if (parent) {
                let existing = parent.items.find(menu => menu.name === newMenuItem.name);
                if (existing) {
                    existing = Object.assign({}, newMenuItem);
                }
                else {
                    parent.items.push(Object.assign({}, newMenuItem));
                }
            }
        }
        this.menuItems = menuItems;
    }
    addNewMenuItemToEntities(targetMenu, newMenuItem) {
        let calcRouterLink;
        // Don't add if we already know about this
        if (targetMenu && !targetMenu.find(menu => menu.name === newMenuItem.name)) {
            // Router bits
            if (newMenuItem.routerLink && newMenuItem.routerLink.indexOf(',') > -1) {
                calcRouterLink = newMenuItem.routerLink.split(',');
            }
            else {
                calcRouterLink = newMenuItem.routerLink;
            }
            const createdMenuItem = Object.assign(Object.assign({}, newMenuItem), { routerLink: calcRouterLink });
            targetMenu.push(createdMenuItem);
            if (newMenuItem.items && newMenuItem.items.length > 0) {
                createdMenuItem.items = [];
                const castItems = newMenuItem.items;
                castItems.forEach(menuItem => {
                    this.addNewMenuItemToEntities(createdMenuItem.items, menuItem);
                });
            }
        }
    }
}
MenuService.ɵfac = function MenuService_Factory(t) { return new (t || MenuService)(ɵɵinject(HttpClient), ɵɵinject(MenuStore), ɵɵinject(MenuQuery), ɵɵinject(AppSettingsQuery), ɵɵinject(UserAuthenticationQuery), ɵɵinject(LoggingService), ɵɵinject(RolesService)); };
MenuService.ɵprov = ɵɵdefineInjectable({ token: MenuService, factory: MenuService.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(MenuService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: HttpClient }, { type: MenuStore }, { type: MenuQuery }, { type: AppSettingsQuery }, { type: UserAuthenticationQuery }, { type: LoggingService }, { type: RolesService }]; }, null); })();

let ReferenceValuesStore = class ReferenceValuesStore extends EntityStore {
    constructor() {
        super({ isInitialised: false });
        console.log('ReferenceValuesStore Constructor');
    }
};
ReferenceValuesStore.ɵfac = function ReferenceValuesStore_Factory(t) { return new (t || ReferenceValuesStore)(); };
ReferenceValuesStore.ɵprov = ɵɵdefineInjectable({ token: ReferenceValuesStore, factory: ReferenceValuesStore.ɵfac, providedIn: 'root' });
ReferenceValuesStore = __decorate([
    StoreConfig({ name: 'referenceValues', idKey: 'compositeKey' })
], ReferenceValuesStore);
/*@__PURE__*/ (function () { ɵsetClassMetadata(ReferenceValuesStore, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();

class ReferenceValuesQuery extends QueryEntity {
    constructor(store) {
        super(store);
        this.store = store;
        this.isInitialised$ = this.select(state => state.isInitialised);
    }
}
ReferenceValuesQuery.ɵfac = function ReferenceValuesQuery_Factory(t) { return new (t || ReferenceValuesQuery)(ɵɵinject(ReferenceValuesStore)); };
ReferenceValuesQuery.ɵprov = ɵɵdefineInjectable({ token: ReferenceValuesQuery, factory: ReferenceValuesQuery.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(ReferenceValuesQuery, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ReferenceValuesStore }]; }, null); })();

class ReferenceValuesService {
    constructor(http, appSettingsService, refValuesQuery, refValuesStore, logger) {
        this.http = http;
        this.appSettingsService = appSettingsService;
        this.refValuesQuery = refValuesQuery;
        this.refValuesStore = refValuesStore;
        this.logger = logger;
        this.className = 'ReferenceValuesService';
        this.requestsInFlight = new Map();
    }
    //
    // Get a single string value from References
    //
    getValue(name, group) {
        return new Observable(observer => {
            this.getReferenceValue(name, group).subscribe(reference => {
                if (reference) {
                    observer.next(reference.value);
                }
                else {
                    observer.next(null);
                }
                observer.complete();
            });
        });
    }
    // Clear all Reference values with this name as root of key
    clearReferenceValue(clearNames) {
        let namesArray;
        if (Array.isArray(clearNames)) {
            namesArray = clearNames;
        }
        else {
            namesArray = [clearNames];
        }
        for (const loopName of namesArray) {
            const list = this.refValuesQuery.getAll({ filterBy: entity => entity.name.startsWith(loopName) });
            for (const refValue of list) {
                this.refValuesStore.remove(refValue.compositeKey);
            }
        }
    }
    setReferenceValue(referenceValue) {
        referenceValue.compositeKey = this.getKey(referenceValue.name, '');
        this.refValuesStore.upsert(this.getKey(referenceValue.name, ''), referenceValue);
    }
    isExpired(refVal) {
        const cacheSeconds = refVal.cacheSeconds || 31556952; // Default to a year
        const nowDate = new Date();
        const expires = new Date(refVal.whenStored);
        expires.setSeconds(expires.getSeconds() + cacheSeconds);
        return nowDate > expires;
    }
    //
    // Get a complex ReferenceValue (May include multiple values)
    //
    getReferenceValue(name, seed = '', childDepth = 0) {
        if (this.refValuesQuery.hasEntity(this.getKey(name, seed))) {
            const cacheValue = this.refValuesQuery.getEntity(this.getKey(name, seed));
            if (this.isExpired(cacheValue)) {
                // Expired cache value. Go get a new one
                return this.downloadRefValue(name, seed);
            }
            // If we get one from Cache, thats handy to use
            this.logger.info(`Reference Values From Cache ${name}::${seed}`);
            return new Observable(observer => {
                observer.next(this.refValuesQuery.getEntity(this.getKey(name, seed)));
                observer.complete();
            });
        }
        else if (childDepth > 0) {
            const refValue = this.refValuesQuery.getEntity(this.getKey(name, ''));
            if (refValue) {
                const parentRef = refValue.referenceValueItems.find(parent => parent.value === seed);
                if (parentRef) {
                    const clone = Object.assign({}, refValue);
                    clone.referenceValueItems = parentRef.referenceValueItems;
                    return new Observable(observer => {
                        observer.next(clone);
                        observer.complete();
                    });
                }
            }
        }
        else {
            return this.downloadRefValue(name, seed);
        }
    }
    downloadRefValue(name, seed) {
        // Nothing in the Cache
        if (this.requestsInFlight.has(this.getKey(name, seed))) {
            // We have already asked for this, return our existing Observable
            return this.requestsInFlight.get(this.getKey(name, seed));
        }
        else {
            const wrapper = new Observable(observer => {
                // Call HTTP Here
                this.logger.info(`Reference Values From HTTP ${name}::${seed}`);
                const httpRequest = this.http
                    .get(`${this.appSettingsService.getValue(AppSettings.apiHome)}/api/v1/referencevalues?name=${name}&seed=${seed}`)
                    .pipe(timeout(20000), retry(3));
                httpRequest.subscribe(value => {
                    value.compositeKey = this.getKey(name, seed);
                    value.whenStored = new Date();
                    this.refValuesStore.upsert(this.getKey(name, seed), value);
                    this.requestsInFlight.delete(this.getKey(name, seed));
                    observer.next(value);
                    observer.complete();
                }, err => {
                    // Error here. If we have a valid value, respond with that
                    if (this.refValuesQuery.hasEntity(this.getKey(name, seed))) {
                        this.logger.info(`Reference Values From HTTP Failed using last Cache ${name}::${seed}`);
                        observer.next(this.refValuesQuery.getEntity(this.getKey(name, seed)));
                        observer.complete();
                    }
                    else {
                        observer.error(err);
                    }
                });
            });
            this.requestsInFlight.set(this.getKey(name, seed), wrapper);
            return wrapper;
        }
    }
    getKey(name, seed) {
        return `${name}::${seed}`;
    }
}
ReferenceValuesService.ɵfac = function ReferenceValuesService_Factory(t) { return new (t || ReferenceValuesService)(ɵɵinject(HttpClient), ɵɵinject(AppSettingsService), ɵɵinject(ReferenceValuesQuery), ɵɵinject(ReferenceValuesStore), ɵɵinject(LoggingService)); };
ReferenceValuesService.ɵprov = ɵɵdefineInjectable({ token: ReferenceValuesService, factory: ReferenceValuesService.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(ReferenceValuesService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: HttpClient }, { type: AppSettingsService }, { type: ReferenceValuesQuery }, { type: ReferenceValuesStore }, { type: LoggingService }]; }, null); })();

class SpinnerService {
    constructor(broadcastService) {
        this.broadcastService = broadcastService;
    }
    showSpinner(message = null) {
        this.broadcastService.broadcast("SHOW_SPINNER" /* SHOW_SPINNER */, message);
    }
    hideSpinner() {
        this.broadcastService.broadcast("HIDE_SPINNER" /* HIDE_SPINNER */);
    }
}
SpinnerService.ɵfac = function SpinnerService_Factory(t) { return new (t || SpinnerService)(ɵɵinject(BroadcastService)); };
SpinnerService.ɵprov = ɵɵdefineInjectable({ token: SpinnerService, factory: SpinnerService.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(SpinnerService, [{
        type: Injectable,
        args: [{
                providedIn: 'root',
            }]
    }], function () { return [{ type: BroadcastService }]; }, null); })();

class UserAuthenticationBase {
}
UserAuthenticationBase.ɵfac = function UserAuthenticationBase_Factory(t) { return new (t || UserAuthenticationBase)(); };
UserAuthenticationBase.ɵprov = ɵɵdefineInjectable({ token: UserAuthenticationBase, factory: UserAuthenticationBase.ɵfac });
/*@__PURE__*/ (function () { ɵsetClassMetadata(UserAuthenticationBase, [{
        type: Injectable
    }], null, null); })();

class UserAuthenticationService {
    constructor(logger, http, authStore, authQuery, appSettingsService, router) {
        this.logger = logger;
        this.http = http;
        this.authStore = authStore;
        this.authQuery = authQuery;
        this.appSettingsService = appSettingsService;
        this.router = router;
        this.tokenStorageKey = 'USER_TOKEN';
        logger.info('UserAuthorisationService - Constructor');
        this.jwtHelper = new JwtHelperService({});
        this.loadUserTokenFromStorage();
    }
    filterItemsByRole(authItems) {
        const returnItems = [];
        if (authItems) {
            authItems.forEach(authItem => {
                if (this.checkByRoles(authItem)) {
                    returnItems.push(authItem);
                }
            });
        }
        return returnItems;
    }
    // Check if user passes muster
    checkByRoles(authItem) {
        // No roles = always okay
        if (!authItem.roles) {
            return true;
        }
        let isAllowed = false;
        const user = this.authQuery.getUser();
        if (user.role) {
            user.role.forEach(role => {
                authItem.roles.forEach(authRole => {
                    if (role === authRole) {
                        isAllowed = true;
                    }
                });
            });
        }
        return isAllowed;
    }
    completeAuthentication() { }
    isAuthenticated() {
        const token = this.getToken();
        const tokenDetails = this.jwtHelper.decodeToken(token);
        return tokenDetails && !this.jwtHelper.isTokenExpired(token);
    }
    authorizationHeaderValue() { }
    name() {
        return 'Hello World';
    }
    forceLogon(returnUrl) {
        this.logoff();
        this.router.navigate(['login'], { queryParams: { returnUrl: returnUrl } });
    }
    getToken() {
        return this.authQuery.getValue().token;
    }
    loadUserTokenFromStorage() {
        const savedToken = localStorage.getItem(this.tokenStorageKey); // Loaded from Saved Storage
        if (savedToken !== null) {
            // New AuthUser Based on Token
            if (!this.jwtHelper.isTokenExpired(savedToken)) {
                // If all Good
                this.logger.info('Token from Storage - Token Loaded and not Expired');
                this.setToken(savedToken);
            }
            else {
                // Expired Token
                this.logger.info('Token from Storage - Token Expired - Not using');
            }
        }
        else {
            // No token
            this.logger.info('Token from Storage - No Token Available');
        }
    }
    setToken(token) {
        // New AuthUser Based on Token
        const tokenDetails = this.jwtHelper.decodeToken(token);
        const newUser = new BasicUser();
        if (tokenDetails['firstName'] && tokenDetails['lastName']) {
            newUser.name = tokenDetails['firstName'] + ' ' + tokenDetails['lastName'];
        }
        if (tokenDetails['sub']) {
            newUser.userId = tokenDetails['sub'];
        }
        if (tokenDetails['role']) {
            newUser.role = tokenDetails['role'];
        }
        if (tokenDetails['email']) {
            newUser.email = tokenDetails['email'];
        }
        this.authStore.update({ token: token, userDetails: newUser, authenticated: true });
    }
    logon(userName, password) {
        return new Observable(observer => {
            let body = new HttpParams();
            body = body
                .append('username', userName)
                .append('password', password)
                .append('grant_type', 'password')
                .append('client_id', this.appSettingsService.getValue(AppSettings.authClientId))
                .append('client_secret', this.appSettingsService.getValue(AppSettings.authClientSecret))
                .append('scope', this.appSettingsService.getValue(AppSettings.authScope) + ' offline_access openid');
            this.http
                .post(this.appSettingsService.getValue(AppSettings.apiAuth) + this.appSettingsService.getValue(AppSettings.authTokenEndpoint), body, {
                headers: new HttpHeaders().set('Content-Type', 'application/x-www-form-urlencoded')
            })
                .pipe(timeout(30000))
                .subscribe(response => {
                // chek if user is is in 'user' role
                const tokenDetails = this.jwtHelper.decodeToken(response['access_token']);
                const requiredRole = this.appSettingsService.getValue(AppSettings.authRequiredRole);
                if (tokenDetails['role']) {
                    if (requiredRole && !tokenDetails['role'].includes(requiredRole)) {
                        observer.error('Unauthorised');
                    }
                    else {
                        // Save Token in Storage if needed
                        if (this.appSettingsService.getValue(AppSettings.authSaveinLocalStorage)) {
                            localStorage.setItem(this.tokenStorageKey, response['access_token']);
                        }
                        // Load our details from this token
                        this.setToken(response['access_token']);
                        if (response['refresh_token']) {
                            // this.refreshToken = response['refresh_token'];
                        }
                        observer.next(null);
                        observer.complete();
                    }
                }
            }, err => {
                observer.error(err);
            });
        });
    }
    logoff() {
        if (this.appSettingsService.getValue(AppSettings.authSaveinLocalStorage)) {
            // Remove token from Local Storage
            localStorage.removeItem(this.tokenStorageKey);
        }
        // Clear Akita Stores
        resetStores({ exclude: ['appSettings'] });
        this.authStore.update({ token: null, userDetails: null, authenticated: false });
    }
}
UserAuthenticationService.ɵfac = function UserAuthenticationService_Factory(t) { return new (t || UserAuthenticationService)(ɵɵinject(LoggingService), ɵɵinject(HttpClient), ɵɵinject(AuthenticationStore), ɵɵinject(UserAuthenticationQuery), ɵɵinject(AppSettingsService), ɵɵinject(Router)); };
UserAuthenticationService.ɵprov = ɵɵdefineInjectable({ token: UserAuthenticationService, factory: UserAuthenticationService.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(UserAuthenticationService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: LoggingService }, { type: HttpClient }, { type: AuthenticationStore }, { type: UserAuthenticationQuery }, { type: AppSettingsService }, { type: Router }]; }, null); })();

class OAuthService {
    constructor(authStore, authQuery, appSettingsQuery) {
        this.authStore = authStore;
        this.authQuery = authQuery;
        this.appSettingsQuery = appSettingsQuery;
        this.jwtHelper = new JwtHelperService({});
        appSettingsQuery
            .selectEntity(AppSettings.authOAuthSettings)
            .subscribe((settings) => {
            this.manager = new UserManager(settings.value);
            this.manager.getUser().then((user) => {
                if (user) {
                    this.user = user;
                    this.setToken(this.user.access_token);
                }
            });
        });
    }
    filterItemsByRole(authItems) {
        const returnItems = [];
        if (authItems) {
            authItems.forEach((authItem) => {
                if (this.checkByRoles(authItem)) {
                    returnItems.push(authItem);
                }
            });
        }
        return returnItems;
    }
    // Check if user passes muster
    checkByRoles(authItem) {
        // No roles = always okay
        if (!authItem.roles) {
            return true;
        }
        let isAllowed = false;
        const user = this.authQuery.getUser();
        if (user.role) {
            user.role.forEach((role) => {
                authItem.roles.forEach((authRole) => {
                    if (role === authRole) {
                        isAllowed = true;
                    }
                });
            });
        }
        return isAllowed;
    }
    getToken() {
        return this.user.access_token;
    }
    forceLogon() {
        this.logon();
    }
    logon(userName = '', password = '') {
        return this.manager.signinRedirect();
    }
    logoff() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.manager.signoutRedirect();
        });
    }
    completeAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            this.user = yield this.manager.signinRedirectCallback();
            this.setToken(this.user.access_token);
        });
    }
    isAuthenticated() {
        this.manager.getUser().then((user) => {
            this.user = user;
        });
        return this.user != null && !this.user.expired;
    }
    authorizationHeaderValue() {
        return `${this.user.token_type} ${this.user.access_token}`;
    }
    name() {
        return this.user != null ? this.user.profile.name : '';
    }
    setToken(token) {
        // New AuthUser Based on Token
        const tokenDetails = this.jwtHelper.decodeToken(token);
        const newUser = new BasicUser();
        if (tokenDetails['name']) {
            newUser.name = tokenDetails['name'];
        }
        else if (tokenDetails['firstName'] && tokenDetails['lastName']) {
            newUser.name = tokenDetails['firstName'] + ' ' + tokenDetails['lastName'];
        }
        if (tokenDetails['role']) {
            newUser.role = tokenDetails['role'];
        }
        if (tokenDetails['email']) {
            newUser.userId = tokenDetails['email'];
            newUser.email = tokenDetails['email'];
        }
        this.authStore.update({
            token: token,
            userDetails: newUser,
            authenticated: true,
        });
    }
}
OAuthService.ɵfac = function OAuthService_Factory(t) { return new (t || OAuthService)(ɵɵinject(AuthenticationStore), ɵɵinject(UserAuthenticationQuery), ɵɵinject(AppSettingsQuery)); };
OAuthService.ɵprov = ɵɵdefineInjectable({ token: OAuthService, factory: OAuthService.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(OAuthService, [{
        type: Injectable,
        args: [{
                providedIn: 'root',
            }]
    }], function () { return [{ type: AuthenticationStore }, { type: UserAuthenticationQuery }, { type: AppSettingsQuery }]; }, null); })();

let UserPreferencesStore = class UserPreferencesStore extends EntityStore {
    constructor() {
        super({ isInitialised: false });
        console.log('UserPreferencesStore Constructor');
    }
};
UserPreferencesStore.ɵfac = function UserPreferencesStore_Factory(t) { return new (t || UserPreferencesStore)(); };
UserPreferencesStore.ɵprov = ɵɵdefineInjectable({ token: UserPreferencesStore, factory: UserPreferencesStore.ɵfac, providedIn: 'root' });
UserPreferencesStore = __decorate([
    StoreConfig({ name: 'userPreferences', idKey: 'name' })
], UserPreferencesStore);
/*@__PURE__*/ (function () { ɵsetClassMetadata(UserPreferencesStore, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();

class UserPreferencesQuery extends QueryEntity {
    constructor(store) {
        super(store);
        this.store = store;
        this.isInitialised$ = this.select(state => state.isInitialised);
    }
}
UserPreferencesQuery.ɵfac = function UserPreferencesQuery_Factory(t) { return new (t || UserPreferencesQuery)(ɵɵinject(UserPreferencesStore)); };
UserPreferencesQuery.ɵprov = ɵɵdefineInjectable({ token: UserPreferencesQuery, factory: UserPreferencesQuery.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(UserPreferencesQuery, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: UserPreferencesStore }]; }, null); })();

class UserPreferencesService {
    constructor(http, authQuery, appSettingsQuery, logger, userPrefsStore, userPrefsQuery, appSettings) {
        this.http = http;
        this.authQuery = authQuery;
        this.appSettingsQuery = appSettingsQuery;
        this.logger = logger;
        this.userPrefsStore = userPrefsStore;
        this.userPrefsQuery = userPrefsQuery;
        this.appSettings = appSettings;
        this.className = 'UserPreferencesService';
        this.prefix = 'preference_';
        this.storageKey = 'UserPreferences';
        this.valuesDownloaded = false;
        this.definitionsDownloaded = false;
        this.httpInFlight = 0;
        // Wait for settings, then load from server
        combineLatest([this.authQuery.authenticated$, this.appSettingsQuery.selectEntity(AppSettings.apiHome)]).subscribe(([authenticated, apiHome]) => {
            if (authenticated && apiHome && !this.valuesDownloaded && !this.definitionsDownloaded) {
                this.apiHome = apiHome.value;
                if (!this.httpInFlight) {
                    // Load User Prefs from Localstorage
                    this.loadFromLocal();
                    // Load Pref Defs from server
                    this.getDefinitions();
                    // Load User Prefs from Server
                    this.getValues();
                }
            }
            else if (!authenticated) {
                // Clear Here as we logoff
                this.clearValues();
            }
        });
    }
    clearValues() {
        this.userPrefsStore.remove();
        // Save to LocalStorage
        localStorage.removeItem(this.storageKey);
    }
    deleteValue(name) {
        return new Observable(observer => {
            this.http.delete(`${this.appSettings.getValue(AppSettings.apiHome)}/api/v1/userpreferencevalue/${name}`).subscribe(() => {
                // Remove and tell the world
                this.userPrefsStore.remove(name);
                localStorage.removeItem(this.storageKey);
                this.saveToLocal();
                observer.next();
                observer.complete();
            }, err => {
                observer.error(err);
            });
        });
    }
    getValues() {
        // Load values from Server
        this.httpInFlight++;
        this.http.get(`${this.appSettings.getValue(AppSettings.apiHome)}/api/v1/userpreferencevalue`).subscribe(prefValues => {
            if (prefValues) {
                prefValues.forEach(prefValue => {
                    this.userPrefsStore.upsert(prefValue.name, prefValue);
                });
                this.userPrefsStore.setLoading(false);
                this.httpInFlight--;
                this.valuesDownloaded = true;
            }
        }, err => {
            this.httpInFlight--;
            this.logger.error(err, this.className, true);
        });
    }
    setValue(key, value) {
        return new Observable(observer => {
            this.http.post(`${this.appSettings.getValue(AppSettings.apiHome)}/api/v1/userpreferencevalue`, { name: key, value: value }).subscribe(() => {
                const existingEntity = this.userPrefsQuery.getEntity(key);
                let newEntity = new UserPreferenceValue();
                if (existingEntity) {
                    newEntity = JSON.parse(JSON.stringify(existingEntity));
                }
                else {
                    newEntity.name = key;
                    newEntity.userId = this.authQuery.getValue().userDetails.userId;
                }
                newEntity.value = value;
                this.userPrefsStore.upsert(key, newEntity);
                observer.next();
                observer.complete();
            }, err => {
                observer.error(err);
            });
        });
    }
    getDefinitions() {
        this.httpInFlight++;
        this.http.get(`${this.appSettings.getValue(AppSettings.apiHome)}/api/v1/UserPreferenceDefinition`).subscribe(prefDefinitions => {
            if (prefDefinitions && prefDefinitions.length > 0) {
                let defns = [];
                prefDefinitions.forEach(definition => {
                    defns.push(definition);
                });
                this.httpInFlight--;
                this.definitionsDownloaded = true;
                this.userPrefsStore.update({ preferenceDefinitions: defns });
            }
        }, err => {
            this.httpInFlight--;
        });
    }
    loadFromLocal() {
        const stored = localStorage.getItem(this.storageKey);
        if (stored) {
            const map = JSON.parse(stored);
            if (map && map.length > 0) {
                map.forEach(value => {
                    // this.userPrefsStore.upsert(value.name, value.value);
                });
            }
        }
    }
    saveToLocal() {
        // Save to LocalStorage
        const serial = JSON.stringify(this.userPrefsQuery.getValue().entities);
        localStorage.setItem(this.storageKey, serial);
    }
}
UserPreferencesService.ɵfac = function UserPreferencesService_Factory(t) { return new (t || UserPreferencesService)(ɵɵinject(HttpClient), ɵɵinject(UserAuthenticationQuery), ɵɵinject(AppSettingsQuery), ɵɵinject(LoggingService), ɵɵinject(UserPreferencesStore), ɵɵinject(UserPreferencesQuery), ɵɵinject(AppSettingsService)); };
UserPreferencesService.ɵprov = ɵɵdefineInjectable({ token: UserPreferencesService, factory: UserPreferencesService.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(UserPreferencesService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: HttpClient }, { type: UserAuthenticationQuery }, { type: AppSettingsQuery }, { type: LoggingService }, { type: UserPreferencesStore }, { type: UserPreferencesQuery }, { type: AppSettingsService }]; }, null); })();

let WidgetStore = class WidgetStore extends EntityStore {
    constructor() {
        super();
        console.log('WidgetStore Constructor');
    }
};
WidgetStore.ɵfac = function WidgetStore_Factory(t) { return new (t || WidgetStore)(); };
WidgetStore.ɵprov = ɵɵdefineInjectable({ token: WidgetStore, factory: WidgetStore.ɵfac, providedIn: 'root' });
WidgetStore = __decorate([
    StoreConfig({ name: 'widget', idKey: 'name' })
], WidgetStore);
/*@__PURE__*/ (function () { ɵsetClassMetadata(WidgetStore, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();

class WidgetQuery extends QueryEntity {
    constructor(store) {
        super(store);
        this.store = store;
    }
}
WidgetQuery.ɵfac = function WidgetQuery_Factory(t) { return new (t || WidgetQuery)(ɵɵinject(WidgetStore)); };
WidgetQuery.ɵprov = ɵɵdefineInjectable({ token: WidgetQuery, factory: WidgetQuery.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(WidgetQuery, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: WidgetStore }]; }, null); })();

class WidgetService {
    constructor(http, widgetStore, widgetQuery, appSettingsQuery, authQuery, log, rolesService) {
        this.http = http;
        this.widgetStore = widgetStore;
        this.widgetQuery = widgetQuery;
        this.appSettingsQuery = appSettingsQuery;
        this.authQuery = authQuery;
        this.log = log;
        this.rolesService = rolesService;
        this.className = 'core.WidgetService';
        // First Time load away
        this.widgetStore.setLoading(false);
        // Wait for settings, then load from server
        combineLatest(this.authQuery.authenticated$, this.appSettingsQuery.selectEntity(AppSettings.apiHome)).subscribe(([authenticated, apiHome]) => {
            if (authenticated && apiHome) {
                this.apiHome = apiHome.value;
                this.widgetQuery
                    .selectLoading()
                    .pipe(take(1))
                    .subscribe(loading => {
                    if (!loading) {
                        this.downloadWidgetItems();
                    }
                });
            }
            else if (!authenticated) {
                this.widgetStore.remove();
            }
        });
    }
    downloadWidgetItems() {
        // Mark loading status
        this.widgetStore.setLoading(true);
        this.http
            .get(this.apiHome + '/api/v1/widgets')
            .pipe(finalize(() => {
            this.widgetStore.setLoading(false);
        }))
            .subscribe(widgetItems => {
            this.widgetStore.add(widgetItems);
        });
    }
}
WidgetService.ɵfac = function WidgetService_Factory(t) { return new (t || WidgetService)(ɵɵinject(HttpClient), ɵɵinject(WidgetStore), ɵɵinject(WidgetQuery), ɵɵinject(AppSettingsQuery), ɵɵinject(UserAuthenticationQuery), ɵɵinject(LoggingService), ɵɵinject(RolesService)); };
WidgetService.ɵprov = ɵɵdefineInjectable({ token: WidgetService, factory: WidgetService.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(WidgetService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: HttpClient }, { type: WidgetStore }, { type: WidgetQuery }, { type: AppSettingsQuery }, { type: UserAuthenticationQuery }, { type: LoggingService }, { type: RolesService }]; }, null); })();

class UserService {
    constructor(http, appSettingsService, authQuery, log, rolesService) {
        this.http = http;
        this.appSettingsService = appSettingsService;
        this.authQuery = authQuery;
        this.log = log;
        this.rolesService = rolesService;
        this.className = 'core.UserService';
    }
    getUsers() {
        return new Observable(observer => {
            this.http.get(`${this.appSettingsService.getValue(AppSettings.apiAuth)}/api/v1/users`);
        }).pipe(timeout(30000));
    }
    createUser(user) {
        return new Observable(observer => {
            this.http.post(`${this.appSettingsService.getValue(AppSettings.apiAuth)}/api/v1/users`, user);
        }).pipe(timeout(30000));
    }
    deleteUser(userId) {
        return new Observable(observer => {
            this.http.delete(`${this.appSettingsService.getValue(AppSettings.apiAuth)}/api/v1/users/${userId}`);
        }).pipe(timeout(30000));
    }
    changePassword(changePasswordModel) {
        return new Observable(observer => {
            this.http.post(`${this.appSettingsService.getValue(AppSettings.apiAuth)}/api/v1/users/changePassword`, changePasswordModel)
                .pipe(timeout(30000))
                .subscribe(response => {
                observer.next(null);
                observer.complete();
            }, err => {
                observer.error(err);
            });
        });
    }
    setPassword(changePasswordModel) {
        return new Observable(observer => {
            this.http.post(`${this.appSettingsService.getValue(AppSettings.apiAuth)}/api/v1/users/setPassword`, changePasswordModel)
                .pipe(timeout(30000))
                .subscribe(response => {
                observer.next(null);
                observer.complete();
            }, err => {
                observer.error(err);
            });
        });
    }
    resetPassword(userId) {
        return new Observable(observer => {
            this.http.get(`${this.appSettingsService.getValue(AppSettings.apiAuth)}/api/v1/users/resetPassword/${userId}`);
        }).pipe(timeout(30000));
    }
    getUser(userId) {
        return new Observable(observer => {
            this.http.get(`${this.appSettingsService.getValue(AppSettings.apiAuth)}/api/v1/users/${userId}`);
        }).pipe(timeout(30000));
    }
    saveUser(user) {
        return new Observable(observer => {
            this.http.post(`${this.appSettingsService.getValue(AppSettings.apiAuth)}/api/v1/users/`, user);
        }).pipe(timeout(30000));
    }
}
UserService.ɵfac = function UserService_Factory(t) { return new (t || UserService)(ɵɵinject(HttpClient), ɵɵinject(AppSettingsService), ɵɵinject(UserAuthenticationQuery), ɵɵinject(LoggingService), ɵɵinject(RolesService)); };
UserService.ɵprov = ɵɵdefineInjectable({ token: UserService, factory: UserService.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(UserService, [{
        type: Injectable,
        args: [{
                providedIn: 'root',
            }]
    }], function () { return [{ type: HttpClient }, { type: AppSettingsService }, { type: UserAuthenticationQuery }, { type: LoggingService }, { type: RolesService }]; }, null); })();

class UserServiceBase {
}

class SoftwareVersion {
}
class VersionsService {
    constructor(logging) {
        this.logging = logging;
        this.versions = [];
    }
    addVersion(module, version, isAppModule = false) {
        this.logging.info(`Loading Module ${module} Version ${version} IsAppModule ${isAppModule}`);
        this.versions.push({
            module: module,
            version: version,
            isAppModule: isAppModule
        });
    }
    getVersions() {
        return this.versions;
    }
    getVersion(moduleName) {
        const foundModule = this.versions.find(v => v.module === moduleName);
        if (foundModule) {
            return foundModule.version;
        }
        else {
            return null;
        }
    }
}
VersionsService.ɵfac = function VersionsService_Factory(t) { return new (t || VersionsService)(ɵɵinject(LoggingService)); };
VersionsService.ɵprov = ɵɵdefineInjectable({ token: VersionsService, factory: VersionsService.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { ɵsetClassMetadata(VersionsService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: LoggingService }]; }, null); })();

class FillHeightDirective {
    constructor(el, logger) {
        this.el = el;
        this.logger = logger;
        this.footerElement = null;
        this.fixedHeight = 0;
        this.relativeToParentPercent = 0;
    }
    ngAfterViewInit() {
        this.calculateAndSetElementHeight();
    }
    onResize(event) {
        this.calculateAndSetElementHeight();
    }
    calculateAndSetElementHeight() {
        if (this.relativeToParentPercent > 0) {
            const parentHeight = this.el.nativeElement.parentNode.parentNode
                .parentNode.parentNode.parentNode.parentNode.offsetHeight;
            if (parentHeight > 0) {
                this.el.nativeElement.style.height = `${parentHeight * (this.relativeToParentPercent / 100)}px`;
            }
        }
        else if (this.fixedHeight > 0) {
            this.el.nativeElement.style.height = `${this.fixedHeight}px`;
        }
        else {
            this.el.nativeElement.style.overflow = 'auto';
            let windowHeight = window.innerHeight;
            if (windowHeight === 0) {
                this.logger.error('FillHeight: Window reported zero height');
                windowHeight = 800;
            }
            const elementOffsetTop = this.getElementOffsetTop();
            const elementMarginBottom = this.el.nativeElement.style.marginBottom;
            const footerElementMargin = this.getfooterElementMargin();
            this.el.nativeElement.style.height = `${windowHeight - footerElementMargin - elementOffsetTop - 16}px`;
        }
    }
    getElementOffsetTop() {
        return this.el.nativeElement.getBoundingClientRect().top;
    }
    getfooterElementMargin() {
        if (!this.footerElement) {
            return 0;
        }
        const footerStyle = window.getComputedStyle(this.footerElement);
        return parseInt(footerStyle.height, 10);
    }
}
FillHeightDirective.ɵfac = function FillHeightDirective_Factory(t) { return new (t || FillHeightDirective)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LoggingService)); };
FillHeightDirective.ɵdir = ɵɵdefineDirective({ type: FillHeightDirective, selectors: [["", "ngsFillHeight", ""]], hostBindings: function FillHeightDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵɵlistener("resize", function FillHeightDirective_resize_HostBindingHandler($event) { return ctx.onResize($event); }, false, ɵɵresolveWindow);
    } }, inputs: { footerElement: "footerElement", fixedHeight: "fixedHeight", relativeToParentPercent: "relativeToParentPercent" } });
/*@__PURE__*/ (function () { ɵsetClassMetadata(FillHeightDirective, [{
        type: Directive,
        args: [{ selector: '[ngsFillHeight]' }]
    }], function () { return [{ type: ElementRef }, { type: LoggingService }]; }, { footerElement: [{
            type: Input
        }], fixedHeight: [{
            type: Input
        }], relativeToParentPercent: [{
            type: Input
        }], onResize: [{
            type: HostListener,
            args: ['window:resize', ['$event']]
        }] }); })();

class ButtonColourPipe {
    transform(inputColor) {
        let returnColor;
        switch (inputColor) {
            case "primary" /* primary */: {
                returnColor = 'p-button-primary';
                break;
            }
            case "secondary" /* secondary */: {
                returnColor = 'p-button-secondary';
                break;
            }
            case "success" /* success */: {
                returnColor = 'p-button-success';
                break;
            }
            case "info" /* info */: {
                returnColor = 'p-button-info';
                break;
            }
            case "warning" /* warning */: {
                returnColor = 'p-button-warning';
                break;
            }
            case "danger" /* danger */: {
                returnColor = 'p-button-danger';
                break;
            }
            case "blue" /* blue */: {
                returnColor = 'blue-grey-btn';
                break;
            }
            case "cyan" /* cyan */: {
                returnColor = 'cyan-btn';
                break;
            }
            case "teal" /* teal */: {
                returnColor = 'teal-btn';
                break;
            }
            case "orange" /* orange */: {
                returnColor = 'orange-btn';
                break;
            }
            case "deeporange" /* deeporange */: {
                returnColor = 'deep-orange-btn';
                break;
            }
            case "purple" /* purple */: {
                returnColor = 'purple-btn';
                break;
            }
            case "indigo" /* indigo */: {
                returnColor = 'indigo-btn';
                break;
            }
            case "pink" /* pink */: {
                returnColor = 'pink-btn';
                break;
            }
            default: {
                returnColor = 'p-button-info';
            }
        }
        return returnColor;
    }
}
ButtonColourPipe.ɵfac = function ButtonColourPipe_Factory(t) { return new (t || ButtonColourPipe)(); };
ButtonColourPipe.ɵpipe = ɵɵdefinePipe({ name: "buttonColour", type: ButtonColourPipe, pure: true });
/*@__PURE__*/ (function () { ɵsetClassMetadata(ButtonColourPipe, [{
        type: Pipe,
        args: [{ name: 'buttonColour' }]
    }], null, null); })();

const dateFormat = dateFormatimp;
class NgsDatePipe {
    constructor(appSettings) {
        this.appSettings = appSettings;
    }
    transform(inputDate) {
        if (inputDate) {
            // If a string gets through, convert to date object
            if (typeof inputDate === 'string' || inputDate instanceof String) {
                inputDate = new Date(inputDate);
            }
            const userTimezoneOffset = inputDate.getTimezoneOffset() * 60000;
            const zuluDate = new Date(inputDate.getTime() + userTimezoneOffset);
            const format = this.appSettings.getEntity(AppSettings.dateFormat);
            if (format && format.value) {
                return dateFormat(zuluDate, format.value);
            }
            else {
                return dateFormat(zuluDate, 'default');
            }
        }
        else {
            return '';
        }
    }
}
NgsDatePipe.ɵfac = function NgsDatePipe_Factory(t) { return new (t || NgsDatePipe)(ɵɵdirectiveInject(AppSettingsQuery)); };
NgsDatePipe.ɵpipe = ɵɵdefinePipe({ name: "ngsDate", type: NgsDatePipe, pure: true });
/*@__PURE__*/ (function () { ɵsetClassMetadata(NgsDatePipe, [{
        type: Pipe,
        args: [{ name: 'ngsDate' }]
    }], function () { return [{ type: AppSettingsQuery }]; }, null); })();

const dateFormat$1 = dateFormatimp;
class NgsDateTimePipe {
    constructor(appSettings) {
        this.appSettings = appSettings;
    }
    transform(inputDate) {
        if (inputDate) {
            // If a string gets through, convert to date object
            if (typeof inputDate === 'string' || inputDate instanceof String) {
                inputDate = new Date(inputDate);
            }
            const userTimezoneOffset = inputDate.getTimezoneOffset() * 60000;
            const zuluDate = new Date(inputDate.getTime() + userTimezoneOffset);
            const format = this.appSettings.getEntity(AppSettings.dateTimeFormat);
            if (format && format.value) {
                return dateFormat$1(zuluDate, format.value);
            }
            else {
                return dateFormat$1(zuluDate, 'default');
            }
        }
        else {
            return '';
        }
    }
}
NgsDateTimePipe.ɵfac = function NgsDateTimePipe_Factory(t) { return new (t || NgsDateTimePipe)(ɵɵdirectiveInject(AppSettingsQuery)); };
NgsDateTimePipe.ɵpipe = ɵɵdefinePipe({ name: "ngsDateTime", type: NgsDateTimePipe, pure: true });
/*@__PURE__*/ (function () { ɵsetClassMetadata(NgsDateTimePipe, [{
        type: Pipe,
        args: [{ name: 'ngsDateTime' }]
    }], function () { return [{ type: AppSettingsQuery }]; }, null); })();

class TruncateTextPipe {
    transform(value, limit = 40, trail = '…') {
        let result = value || '';
        if (value) {
            const words = value.split(/\s+/);
            if (words.length > Math.abs(limit)) {
                if (limit < 0) {
                    limit *= -1;
                    result =
                        trail + words.slice(words.length - limit, words.length).join(' ');
                }
                else {
                    result = words.slice(0, limit).join(' ') + trail;
                }
            }
        }
        return result;
    }
}
TruncateTextPipe.ɵfac = function TruncateTextPipe_Factory(t) { return new (t || TruncateTextPipe)(); };
TruncateTextPipe.ɵpipe = ɵɵdefinePipe({ name: "truncateText", type: TruncateTextPipe, pure: true });
/*@__PURE__*/ (function () { ɵsetClassMetadata(TruncateTextPipe, [{
        type: Pipe,
        args: [{
                name: 'truncateText'
            }]
    }], null, null); })();

class AuthoriseRoleGuard {
    constructor(authService, router, rolesService) {
        this.authService = authService;
        this.router = router;
        this.rolesService = rolesService;
    }
    canActivate(route, state) {
        if (this.authService.isAuthenticated()) {
            return true;
        }
        // No authority, bye bye.
        this.authService.forceLogon(state.url);
        return false;
    }
}
AuthoriseRoleGuard.ɵfac = function AuthoriseRoleGuard_Factory(t) { return new (t || AuthoriseRoleGuard)(ɵɵinject(UserAuthenticationBase), ɵɵinject(Router), ɵɵinject(RolesService)); };
AuthoriseRoleGuard.ɵprov = ɵɵdefineInjectable({ token: AuthoriseRoleGuard, factory: AuthoriseRoleGuard.ɵfac });
/*@__PURE__*/ (function () { ɵsetClassMetadata(AuthoriseRoleGuard, [{
        type: Injectable
    }], function () { return [{ type: UserAuthenticationBase }, { type: Router }, { type: RolesService }]; }, null); })();

class DialogWindowComponent {
    constructor() {
        this.closed = new EventEmitter();
    }
    ngOnChanges(changes) { }
    ngOnDestroy() { }
    ngOnInit() { }
    cancel(event) {
        this.closed.emit(null);
    }
    save(event) {
    }
}
DialogWindowComponent.ɵfac = function DialogWindowComponent_Factory(t) { return new (t || DialogWindowComponent)(); };
DialogWindowComponent.ɵcmp = ɵɵdefineComponent({ type: DialogWindowComponent, selectors: [["ngs-dialog-window"]], outputs: { closed: "closed" }, features: [ɵɵNgOnChangesFeature], decls: 2, vars: 0, template: function DialogWindowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵɵelementStart(0, "h1");
        ɵɵtext(1, "Dialog Window Base Class");
        ɵɵelementEnd();
    } }, styles: [""] });
/*@__PURE__*/ (function () { ɵsetClassMetadata(DialogWindowComponent, [{
        type: Component,
        args: [{
                selector: 'ngs-dialog-window',
                templateUrl: 'dialogWindow.component.html',
                styleUrls: ['dialogWindow.component.scss']
            }]
    }], null, { closed: [{
            type: Output
        }] }); })();

// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!
/* tslint:disable */
const VERSION = {
    "dirty": true,
    "raw": "608f2a0-dirty",
    "hash": "608f2a0",
    "distance": null,
    "tag": null,
    "semver": null,
    "suffix": "608f2a0-dirty",
    "semverString": null,
    "version": "1.1.20"
};
/* tslint:enable */

class CoreModule {
    constructor(versions) {
        versions.addVersion('@ngscaffolding/core', VERSION.version);
    }
    static forRoot() {
        return {
            ngModule: CoreModule
        };
    }
}
CoreModule.ɵmod = ɵɵdefineNgModule({ type: CoreModule });
CoreModule.ɵinj = ɵɵdefineInjector({ factory: function CoreModule_Factory(t) { return new (t || CoreModule)(ɵɵinject(VersionsService)); }, imports: [[CommonModule, FormsModule, HttpClientModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(CoreModule, { declarations: [FillHeightDirective,
        ButtonColourPipe,
        NgsDatePipe,
        NgsDateTimePipe,
        TruncateTextPipe,
        DialogWindowComponent], imports: [CommonModule, FormsModule, HttpClientModule], exports: [ButtonColourPipe,
        NgsDatePipe,
        NgsDateTimePipe,
        TruncateTextPipe,
        FillHeightDirective,
        DialogWindowComponent] }); })();
/*@__PURE__*/ (function () { ɵsetClassMetadata(CoreModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, FormsModule, HttpClientModule],
                declarations: [
                    FillHeightDirective,
                    ButtonColourPipe,
                    NgsDatePipe,
                    NgsDateTimePipe,
                    TruncateTextPipe,
                    DialogWindowComponent
                ],
                exports: [
                    ButtonColourPipe,
                    NgsDatePipe,
                    NgsDateTimePipe,
                    TruncateTextPipe,
                    FillHeightDirective,
                    DialogWindowComponent
                ]
            }]
    }], function () { return [{ type: VersionsService }]; }, null); })();

/*
 * Public API Surface of core
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AppAuditService, AppSettingsQuery, AppSettingsService, AppSettingsStore, AuditLogService, AuthenticationStore, AuthoriseRoleGuard, BroadcastService, ButtonColourPipe, ComponentLoaderService, CoreErrorHandlerService, CoreModule, DataSourceQuery, DataSourceService, DataSourceStore, DialogWindowComponent, FillHeightDirective, LoggingService, MenuQuery, MenuService, MenuStore, NgsDatePipe, NgsDateTimePipe, NotificationService, OAuthService, ReferenceValuesQuery, ReferenceValuesService, ReferenceValuesStore, RolesQuery, RolesService, RolesStore, SoftwareVersion, SpinnerService, TruncateTextPipe, UserAuthenticationBase, UserAuthenticationQuery, UserAuthenticationService, UserPreferencesQuery, UserPreferencesService, UserPreferencesStore, UserService, UserServiceBase, VersionsService, WidgetQuery, WidgetService, WidgetStore };
//# sourceMappingURL=ngscaffolding-core.js.map
