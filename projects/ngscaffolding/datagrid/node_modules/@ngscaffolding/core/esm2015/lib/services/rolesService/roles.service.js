import { Injectable } from '@angular/core';
import { combineLatest } from 'rxjs';
import { AppSettings } from '@ngscaffolding/models';
import { take, finalize } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
import * as i2 from "./roles.query";
import * as i3 from "../appSettings/appSettings.query";
import * as i4 from "../dataSource/dataSource.service";
import * as i5 from "./roles.store";
import * as i6 from "../userAuthentication/userAuthentication.query";
export class RolesService {
    constructor(http, rolesQuery, appSettingsQuery, dataSourceService, rolesStore, authQuery) {
        this.http = http;
        this.rolesQuery = rolesQuery;
        this.appSettingsQuery = appSettingsQuery;
        this.dataSourceService = dataSourceService;
        this.rolesStore = rolesStore;
        this.authQuery = authQuery;
        this.routeRoles = new Map();
        // First Time load away
        this.rolesStore.setLoading(false);
        // Wait for settings, then load from server
        combineLatest(this.authQuery.authenticated$, this.appSettingsQuery.selectEntity(AppSettings.apiHome)).subscribe(([authenticated, apiHome]) => {
            if (authenticated && apiHome) {
                this.apiHome = apiHome.value;
                this.rolesQuery
                    .selectLoading()
                    .pipe(take(1))
                    .subscribe(loading => {
                    if (!loading) {
                        this.downloadRoles();
                    }
                });
            }
            else if (!authenticated) {
                this.rolesStore.remove();
            }
        });
    }
    downloadRoles() {
        // Mark loading status
        this.rolesStore.setLoading(true);
        this.dataSourceService
            .getDataSource({ name: "system.Roles.Select" /* ROLES_SELECT */ })
            .pipe(finalize(() => {
            this.rolesStore.setLoading(false);
        }))
            .subscribe(results => {
            if (results && !results.error) {
                this.rolesStore.add(results.jsonData);
                this.rolesStore.setLoading(false);
            }
        });
    }
    // Checks if the current user is in this role.
    isInRole(role) {
        const currentUser = this.authQuery.getValue().userDetails;
        if (currentUser && currentUser.role) {
            return currentUser.role.indexOf(role) > -1;
        }
        else {
            return false;
        }
    }
    // Checks if the current user is in one of these roles.
    isInRoles(roles) {
        let result = false;
        const currentUser = this.authQuery.getValue().userDetails;
        if (currentUser && currentUser.role) {
            roles.forEach(role => {
                if (currentUser.role.indexOf(role) > -1) {
                    result = true;
                }
            });
        }
        return result;
    }
    // Repository of Roles: Routes
    addRouteRoles(route, roles) {
        this.routeRoles.set(route, roles);
    }
    getRouteRoles(route) {
        return this.routeRoles.get(route);
    }
}
RolesService.ɵfac = function RolesService_Factory(t) { return new (t || RolesService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.RolesQuery), i0.ɵɵinject(i3.AppSettingsQuery), i0.ɵɵinject(i4.DataSourceService), i0.ɵɵinject(i5.RolesStore), i0.ɵɵinject(i6.UserAuthenticationQuery)); };
RolesService.ɵprov = i0.ɵɵdefineInjectable({ token: RolesService, factory: RolesService.ɵfac, providedIn: 'root' });
/*@__PURE__*/ (function () { i0.ɵsetClassMetadata(RolesService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: i1.HttpClient }, { type: i2.RolesQuery }, { type: i3.AppSettingsQuery }, { type: i4.DataSourceService }, { type: i5.RolesStore }, { type: i6.UserAuthenticationQuery }]; }, null); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm9sZXMuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3NjYWZmb2xkaW5nL2NvcmUvc3JjLyIsInNvdXJjZXMiOlsibGliL3NlcnZpY2VzL3JvbGVzU2VydmljZS9yb2xlcy5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFLM0MsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNyQyxPQUFPLEVBQUUsV0FBVyxFQUF5QixNQUFNLHVCQUF1QixDQUFDO0FBQzNFLE9BQU8sRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7Ozs7O0FBT2hELE1BQU0sT0FBTyxZQUFZO0lBSXZCLFlBQ1UsSUFBZ0IsRUFDaEIsVUFBc0IsRUFDdEIsZ0JBQWtDLEVBQ2xDLGlCQUFvQyxFQUNwQyxVQUFzQixFQUN2QixTQUFrQztRQUxqQyxTQUFJLEdBQUosSUFBSSxDQUFZO1FBQ2hCLGVBQVUsR0FBVixVQUFVLENBQVk7UUFDdEIscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQjtRQUNsQyxzQkFBaUIsR0FBakIsaUJBQWlCLENBQW1CO1FBQ3BDLGVBQVUsR0FBVixVQUFVLENBQVk7UUFDdkIsY0FBUyxHQUFULFNBQVMsQ0FBeUI7UUFUbkMsZUFBVSxHQUFHLElBQUksR0FBRyxFQUFvQixDQUFDO1FBVy9DLHVCQUF1QjtRQUN2QixJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUVsQywyQ0FBMkM7UUFDM0MsYUFBYSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxhQUFhLEVBQUUsT0FBTyxDQUFDLEVBQUUs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c0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBVc2VyQXV0aGVudGljYXRpb25RdWVyeSB9IGZyb20gJy4uL3VzZXJBdXRoZW50aWNhdGlvbi91c2VyQXV0aGVudGljYXRpb24ucXVlcnknO1xyXG5pbXBvcnQgeyBSb2xlc1F1ZXJ5IH0gZnJvbSAnLi9yb2xlcy5xdWVyeSc7XHJcbmltcG9ydCB7IFJvbGVzU3RvcmUgfSBmcm9tICcuL3JvbGVzLnN0b3JlJztcclxuaW1wb3J0IHsgQXBwU2V0dGluZ3NRdWVyeSB9IGZyb20gJy4uL2FwcFNldHRpbmdzL2FwcFNldHRpbmdzLnF1ZXJ5JztcclxuaW1wb3J0IHsgY29tYmluZUxhdGVzdCB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBBcHBTZXR0aW5ncywgU3lzdGVtRGF0YVNvdXJjZU5hbWVzIH0gZnJvbSAnQG5nc2NhZmZvbGRpbmcvbW9kZWxzJztcclxuaW1wb3J0IHsgdGFrZSwgZmluYWxpemUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IEh0dHBDbGllbnQgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XHJcbmltcG9ydCB7IERhdGFTb3VyY2VTZXJ2aWNlIH0gZnJvbSAnLi4vZGF0YVNvdXJjZS9kYXRhU291cmNlLnNlcnZpY2UnO1xyXG5cclxuQEluamVjdGFibGUoe1xyXG4gIHByb3ZpZGVkSW46ICdyb290J1xyXG59KVxyXG5leHBvcnQgY2xhc3MgUm9sZXNTZXJ2aWNlIHtcclxuICBwcml2YXRlIHJvdXRlUm9sZXMgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nW10+KCk7XHJcbiAgcHJpdmF0ZSBhcGlIb21lOiBzdHJpbmc7XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcHJpdmF0ZSBodHRwOiBIdHRwQ2xpZW50LFxyXG4gICAgcHJpdmF0ZSByb2xlc1F1ZXJ5OiBSb2xlc1F1ZXJ5LFxyXG4gICAgcHJpdmF0ZSBhcHBTZXR0aW5nc1F1ZXJ5OiBBcHBTZXR0aW5nc1F1ZXJ5LFxyXG4gICAgcHJpdmF0ZSBkYXRhU291cmNlU2VydmljZTogRGF0YVNvdXJjZVNlcnZpY2UsXHJcbiAgICBwcml2YXRlIHJvbGVzU3RvcmU6IFJvbGVzU3RvcmUsXHJcbiAgICBwdWJsaWMgYXV0aFF1ZXJ5OiBVc2VyQXV0aGVudGljYXRpb25RdWVyeVxyXG4gICkge1xyXG4gICAgLy8gRmlyc3QgVGltZSBsb2FkIGF3YXlcclxuICAgIHRoaXMucm9sZXNTdG9yZS5zZXRMb2FkaW5nKGZhbHNlKTtcclxuXHJcbiAgICAvLyBXYWl0IGZvciBzZXR0aW5ncywgdGhlbiBsb2FkIGZyb20gc2VydmVyXHJcbiAgICBjb21iaW5lTGF0ZXN0KHRoaXMuYXV0aFF1ZXJ5LmF1dGhlbnRpY2F0ZWQkLCB0aGlzLmFwcFNldHRpbmdzUXVlcnkuc2VsZWN0RW50aXR5KEFwcFNldHRpbmdzLmFwaUhvbWUpKS5zdWJzY3JpYmUoKFthdXRoZW50aWNhdGVkLCBhcGlIb21lXSkgPT4ge1xyXG4gICAgICBpZiAoYXV0aGVudGljYXRlZCAmJiBhcGlIb21lKSB7XHJcbiAgICAgICAgdGhpcy5hcGlIb21lID0gYXBpSG9tZS52YWx1ZTtcclxuICAgICAgICB0aGlzLnJvbGVzUXVlcnlcclxuICAgICAgICAgIC5zZWxlY3RMb2FkaW5nKClcclxuICAgICAgICAgIC5waXBlKHRha2UoMSkpXHJcbiAgICAgICAgICAuc3Vic2NyaWJlKGxvYWRpbmcgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWxvYWRpbmcpIHtcclxuICAgICAgICAgICAgICB0aGlzLmRvd25sb2FkUm9sZXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoIWF1dGhlbnRpY2F0ZWQpIHtcclxuICAgICAgICB0aGlzLnJvbGVzU3RvcmUucmVtb3ZlKCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGRvd25sb2FkUm9sZXMoKSB7XHJcbiAgICAvLyBNYXJrIGxvYWRpbmcgc3RhdHVzXHJcbiAgICB0aGlzLnJvbGVzU3RvcmUuc2V0TG9hZGluZyh0cnVlKTtcclxuXHJcbiAgICB0aGlzLmRhdGFTb3VyY2VTZXJ2aWNlXHJcbiAgICAgIC5nZXREYXRhU291cmNlKHsgbmFtZTogU3lzdGVtRGF0YVNvdXJjZU5hbWVzLlJPTEVTX1NFTEVDVCB9KVxyXG4gICAgICAucGlwZShcclxuICAgICAgICBmaW5hbGl6ZSgoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLnJvbGVzU3RvcmUuc2V0TG9hZGluZyhmYWxzZSk7XHJcbiAgICAgICAgfSlcclxuICAgICAgKVxyXG4gICAgICAuc3Vic2NyaWJlKHJlc3VsdHMgPT4ge1xyXG4gICAgICAgIGlmIChyZXN1bHRzICYmICFyZXN1bHRzLmVycm9yKSB7XHJcbiAgICAgICAgICB0aGlzLnJvbGVzU3RvcmUuYWRkKHJlc3VsdHMuanNvbkRhdGEpO1xyXG4gICAgICAgICAgdGhpcy5yb2xlc1N0b3JlLnNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBDaGVja3MgaWYgdGhlIGN1cnJlbnQgdXNlciBpcyBpbiB0aGlzIHJvbGUuXHJcbiAgcHVibGljIGlzSW5Sb2xlKHJvbGU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3QgY3VycmVudFVzZXIgPSB0aGlzLmF1dGhRdWVyeS5nZXRWYWx1ZSgpLnVzZXJEZXRhaWxzO1xyXG4gICAgaWYgKGN1cnJlbnRVc2VyICYmIGN1cnJlbnRVc2VyLnJvbGUpIHtcclxuICAgICAgcmV0dXJuIGN1cnJlbnRVc2VyLnJvbGUuaW5kZXhPZihyb2xlKSA+IC0xO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gQ2hlY2tzIGlmIHRoZSBjdXJyZW50IHVzZXIgaXMgaW4gb25lIG9mIHRoZXNlIHJvbGVzLlxyXG4gIHB1YmxpYyBpc0luUm9sZXMocm9sZXM6IHN0cmluZ1tdKTogYm9vbGVhbiB7XHJcbiAgICBsZXQgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICBjb25zdCBjdXJyZW50VXNlciA9IHRoaXMuYXV0aFF1ZXJ5LmdldFZhbHVlKCkudXNlckRldGFpbHM7XHJcbiAgICBpZiAoY3VycmVudFVzZXIgJiYgY3VycmVudFVzZXIucm9sZSkge1xyXG4gICAgICByb2xlcy5mb3JFYWNoKHJvbGUgPT4ge1xyXG4gICAgICAgIGlmIChjdXJyZW50VXNlci5yb2xlLmluZGV4T2Yocm9sZSkgPiAtMSkge1xyXG4gICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcblxyXG4gIC8vIFJlcG9zaXRvcnkgb2YgUm9sZXM6IFJvdXRlc1xyXG4gIHB1YmxpYyBhZGRSb3V0ZVJvbGVzKHJvdXRlOiBzdHJpbmcsIHJvbGVzOiBzdHJpbmdbXSkge1xyXG4gICAgdGhpcy5yb3V0ZVJvbGVzLnNldChyb3V0ZSwgcm9sZXMpO1xyXG4gIH1cclxuXHJcbiAgcHVibGljIGdldFJvdXRlUm9sZXMocm91dGU6IHN0cmluZyk6IHN0cmluZ1tdIHtcclxuICAgIHJldHVybiB0aGlzLnJvdXRlUm9sZXMuZ2V0KHJvdXRlKTtcclxuICB9XHJcbn1cclxuIl19