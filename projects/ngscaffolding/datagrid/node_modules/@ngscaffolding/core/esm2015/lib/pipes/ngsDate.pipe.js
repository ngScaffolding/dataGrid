import * as dateFormatimp from 'dateformat';
import { Pipe } from '@angular/core';
import { AppSettings } from '@ngscaffolding/models';
import * as i0 from "@angular/core";
import * as i1 from "../services/appSettings/appSettings.query";
const dateFormat = dateFormatimp;
export class NgsDatePipe {
    constructor(appSettings) {
        this.appSettings = appSettings;
    }
    transform(inputDate) {
        if (inputDate) {
            // If a string gets through, convert to date object
            if (typeof inputDate === 'string' || inputDate instanceof String) {
                inputDate = new Date(inputDate);
            }
            const userTimezoneOffset = inputDate.getTimezoneOffset() * 60000;
            const zuluDate = new Date(inputDate.getTime() + userTimezoneOffset);
            const format = this.appSettings.getEntity(AppSettings.dateFormat);
            if (format && format.value) {
                return dateFormat(zuluDate, format.value);
            }
            else {
                return dateFormat(zuluDate, 'default');
            }
        }
        else {
            return '';
        }
    }
}
NgsDatePipe.ɵfac = function NgsDatePipe_Factory(t) { return new (t || NgsDatePipe)(i0.ɵɵdirectiveInject(i1.AppSettingsQuery)); };
NgsDatePipe.ɵpipe = i0.ɵɵdefinePipe({ name: "ngsDate", type: NgsDatePipe, pure: true });
/*@__PURE__*/ (function () { i0.ɵsetClassMetadata(NgsDatePipe, [{
        type: Pipe,
        args: [{ name: 'ngsDate' }]
    }], function () { return [{ type: i1.AppSettingsQuery }]; }, null); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmdzRGF0ZS5waXBlLmpzIiwic291cmNlUm9vdCI6Ii4uLy4uLy4uLy4uL3Byb2plY3RzL25nc2NhZmZvbGRpbmcvY29yZS9zcmMvIiwic291cmNlcyI6WyJsaWIvcGlwZXMvbmdzRGF0ZS5waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sS0FBSyxhQUFhLE1BQU0sWUFBWSxDQUFDO0FBRzVDLE9BQU8sRUFBRSxJQUFJLEVBQWlCLE1BQU0sZUFBZSxDQUFDO0FBRXBELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQzs7O0FBSnBELE1BQU0sVUFBVSxHQUFHLGFBQWEsQ0FBQztBQU9qQyxNQUFNLE9BQU8sV0FBVztJQUN0QixZQUFvQixXQUE2QjtRQUE3QixnQkFBVyxHQUFYLFdBQVcsQ0FBa0I7SUFBRyxDQUFDO0lBQ3JELFNBQVMsQ0FBQyxTQUFlO1FBQ3ZCLElBQUksU0FBUyxFQUFFO1lBQ2IsbURBQW1EO1lBQ25ELElBQUksT0FBTyxTQUFTLEtBQUssUUFBUSxJQUFJLFNBQVMsWUFBWSxNQUFNLEVBQUU7Z0JBQ2hFLFNBQVMsR0FBRyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUNqQztZQUVELE1BQU0sa0JBQWtCLEdBQUcsU0FBUyxDQUFDLGlCQUFpQixFQUFFLEdBQUcsS0FBSyxDQUFDO1lBQ2pFLE1BQU0sUUFBUSxHQUFHLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsR0FBRyxrQkFBa0IsQ0FBQyxDQUFDO1lBRXBFLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUNsRSxJQUFJLE1BQU0sSUFBSSxNQUFNLENBQUMsS0FBSyxFQUFFO2dCQUMxQixPQUFPLFVBQVUsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQzNDO2lCQUFNO2dCQUNMLE9BQU8sVUFBVSxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQzthQUN4QztTQUNGO2FBQU07WUFDTCxPQUFPLEVBQUUsQ0FBQztTQUNYO0lBQ0gsQ0FBQzs7c0VBckJVLFdBQVc7NkRBQVgsV0FBVztrREFBWCxXQUFXO2NBRHZCLElBQUk7ZUFBQyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBkYXRlRm9ybWF0aW1wIGZyb20gJ2RhdGVmb3JtYXQnO1xyXG5jb25zdCBkYXRlRm9ybWF0ID0gZGF0ZUZvcm1hdGltcDtcclxuXHJcbmltcG9ydCB7IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQXBwU2V0dGluZ3NRdWVyeSB9IGZyb20gJy4uL3NlcnZpY2VzL2FwcFNldHRpbmdzL2FwcFNldHRpbmdzLnF1ZXJ5JztcclxuaW1wb3J0IHsgQXBwU2V0dGluZ3MgfSBmcm9tICdAbmdzY2FmZm9sZGluZy9tb2RlbHMnO1xyXG5cclxuQFBpcGUoeyBuYW1lOiAnbmdzRGF0ZScgfSlcclxuZXhwb3J0IGNsYXNzIE5nc0RhdGVQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBhcHBTZXR0aW5nczogQXBwU2V0dGluZ3NRdWVyeSkge31cclxuICB0cmFuc2Zvcm0oaW5wdXREYXRlOiBEYXRlKTogc3RyaW5nIHtcclxuICAgIGlmIChpbnB1dERhdGUpIHtcclxuICAgICAgLy8gSWYgYSBzdHJpbmcgZ2V0cyB0aHJvdWdoLCBjb252ZXJ0IHRvIGRhdGUgb2JqZWN0XHJcbiAgICAgIGlmICh0eXBlb2YgaW5wdXREYXRlID09PSAnc3RyaW5nJyB8fCBpbnB1dERhdGUgaW5zdGFuY2VvZiBTdHJpbmcpIHtcclxuICAgICAgICBpbnB1dERhdGUgPSBuZXcgRGF0ZShpbnB1dERhdGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCB1c2VyVGltZXpvbmVPZmZzZXQgPSBpbnB1dERhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwO1xyXG4gICAgICBjb25zdCB6dWx1RGF0ZSA9IG5ldyBEYXRlKGlucHV0RGF0ZS5nZXRUaW1lKCkgKyB1c2VyVGltZXpvbmVPZmZzZXQpO1xyXG5cclxuICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5hcHBTZXR0aW5ncy5nZXRFbnRpdHkoQXBwU2V0dGluZ3MuZGF0ZUZvcm1hdCk7XHJcbiAgICAgIGlmIChmb3JtYXQgJiYgZm9ybWF0LnZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGVGb3JtYXQoenVsdURhdGUsIGZvcm1hdC52YWx1ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGRhdGVGb3JtYXQoenVsdURhdGUsICdkZWZhdWx0Jyk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICB9XHJcbn1cclxuIl19